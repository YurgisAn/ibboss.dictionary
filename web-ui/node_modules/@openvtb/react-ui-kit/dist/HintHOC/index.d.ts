import React from 'react';
import type { ComponentType, RefObject } from 'react';
import type { Align, Direction, Size } from './constants';
export interface IHintHOCProps {
    /** Выравнивание подсказки */
    align?: Align;
    /** Имя класса для переопределения стилей */
    className?: string;
    /** Контейнер, в котором происходит размещение.
     * В отличие от TooltipHOC, данный компонент по дизайну всегда имеет target, относительно
     * которого будет происходить позиционирование - это оборачиваемый компонент (иконка и т.п.) */
    container?: Element | null;
    /** data-test-id атрибут для тестирования компонента */
    dataTestId?: string;
    /** Направление подсказки */
    direction?: Direction;
    /** Светлый вариант подсказки */
    light?: boolean;
    /** Текст подсказки */
    message: string;
    /** Отступ подсказки */
    offset?: number;
    /** Размер подсказки */
    size?: Size;
    /** Показать/скрыть подсказку */
    visible?: boolean;
    /** Обработчик, срабатывающий при попытке пользователя закрыть подсказку */
    onRequestHide?: () => void;
}
interface IHintHOCState {
    pointerAlign: Align;
    pointerDirection: Direction;
    posX: number;
    posY: number;
}
export declare const createHintHOC: <P extends Object>(WrappedComponent: React.ComponentType<P>) => {
    new (props: P & IHintHOCProps): {
        hintRef: RefObject<HTMLDivElement>;
        wrapperRef: RefObject<HTMLDivElement>;
        scrollableParents?: Element[] | undefined;
        componentDidMount(): void;
        componentDidUpdate(prevProps: IHintHOCProps, _: IHintHOCState): void;
        componentWillUnmount(): void;
        handleDocumentClick(e: MouseEvent): void;
        changePosition: () => void;
        handleHide: (e: React.MouseEvent<HTMLDivElement>) => void;
        onHide: () => void;
        renderInformer(): JSX.Element;
        render(): JSX.Element;
        context: any;
        setState<K extends "pointerAlign" | "pointerDirection" | "posX" | "posY">(state: IHintHOCState | ((prevState: Readonly<IHintHOCState>, props: Readonly<P & IHintHOCProps>) => IHintHOCState | Pick<IHintHOCState, K> | null) | Pick<IHintHOCState, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<P & IHintHOCProps> & Readonly<{
            children?: React.ReactNode;
        }>;
        state: Readonly<IHintHOCState>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<P & IHintHOCProps>, nextState: Readonly<IHintHOCState>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<P & IHintHOCProps>, prevState: Readonly<IHintHOCState>): any;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<P & IHintHOCProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<P & IHintHOCProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<P & IHintHOCProps>, nextState: Readonly<IHintHOCState>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<P & IHintHOCProps>, nextState: Readonly<IHintHOCState>, nextContext: any): void;
    };
    contextType?: React.Context<any> | undefined;
};
export {};
//# sourceMappingURL=index.d.ts.map