import React from 'react';
import type { ComponentType, RefObject } from 'react';
declare type Direction = 'bottom' | 'left' | 'right' | 'top';
declare type DisplayType = 'block' | 'inline-block';
export interface ITooltipHOCProps {
    /** Имя класса для переопределения стилей */
    className?: string;
    /** Контейнер, в котором при необходимости можно отрисовать тултип через ReactDOM.createPortal */
    container?: Element | null;
    /** data-test-id атрибут для тестирования компонента */
    dataTestId?: string;
    /** Направление тултипа */
    direction?: Direction;
    /** Параметр display, согласно которому будет отрисован оборачиваемый в HOC компонент. По умолчанию inline-block */
    display?: DisplayType;
    /** Светлый вариант тултипа */
    light?: boolean;
    /** Ссылка на элемент, относительно которого будет позиционироваться тултип, если оборачиваемый в HOC компонент не подходит */
    target?: Element | null;
    /** Текст тултипа */
    tooltip: string;
    /** Отобразить тултип с задержкой в 1.5 секунды */
    withDelay?: boolean;
}
interface ITooltipHOCState {
    pointerDirection: Direction;
    posX: number;
    posY: number;
    showTooltip: boolean;
}
export declare const createTooltipHOC: <P extends Object>(WrappedComponent: React.ComponentType<P>) => {
    new (props: P & ITooltipHOCProps): {
        tooltipRef: RefObject<HTMLDivElement>;
        wrapperRef: RefObject<HTMLDivElement>;
        showTooltipTimer: number;
        scrollableParents?: Element[] | undefined;
        hideTooltip: () => void;
        componentDidMount(): void;
        componentDidUpdate(): void;
        componentWillUnmount(): void;
        handleMouseEnter: () => void;
        handleMouseLeave: () => void;
        renderTooltip(): JSX.Element;
        render(): JSX.Element;
        context: any;
        setState<K extends "pointerDirection" | "posX" | "posY" | "showTooltip">(state: ITooltipHOCState | ((prevState: Readonly<ITooltipHOCState>, props: Readonly<P & ITooltipHOCProps>) => ITooltipHOCState | Pick<ITooltipHOCState, K> | null) | Pick<ITooltipHOCState, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        readonly props: Readonly<P & ITooltipHOCProps> & Readonly<{
            children?: React.ReactNode;
        }>;
        state: Readonly<ITooltipHOCState>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        shouldComponentUpdate?(nextProps: Readonly<P & ITooltipHOCProps>, nextState: Readonly<ITooltipHOCState>, nextContext: any): boolean;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<P & ITooltipHOCProps>, prevState: Readonly<ITooltipHOCState>): any;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<P & ITooltipHOCProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<P & ITooltipHOCProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<P & ITooltipHOCProps>, nextState: Readonly<ITooltipHOCState>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<P & ITooltipHOCProps>, nextState: Readonly<ITooltipHOCState>, nextContext: any): void;
    };
    contextType?: React.Context<any> | undefined;
};
export {};
//# sourceMappingURL=index.d.ts.map