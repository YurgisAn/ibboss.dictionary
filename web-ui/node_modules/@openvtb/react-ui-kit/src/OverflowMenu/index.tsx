import React, {
  FC,
  useState,
  MouseEvent,
  KeyboardEvent,
  useRef,
  MutableRefObject,
  useLayoutEffect,
  ReactNode,
} from 'react';
import { createPortal } from 'react-dom';

import { ReactComponent as MoreOutline } from '../Icons/system/MoreOutline.svg';
import {
  useClickOutside,
  getMenuPlacement,
  moveFocus,
  previousItem,
  nextItem,
  calcMenuPosition,
} from '../Select/utils';

import { DropdownMenu } from './DropDownMenu';
import {
  IconWrapper,
  BaseWrapper,
  IndicatorsWrapper,
  WrapperDropDown,
  DropDownWrapper,
} from './styled-components';
import type { Size, Alignment } from './constants';
import { iconSize } from './constants';

export interface IOverflowMenuItem<T = any> {
  id?: number | string;
  /** Подпись к опции */
  label: string;
  /** Значение опции */
  value: T;
  /** Отключение опции */
  isDisabled?: boolean;
  /** Иконка */
  icon?: ReactNode;
}

export interface IOverflowMenuProps {
  /** Массив опций */
  list: IOverflowMenuItem[];
  /** Размер компонента */
  size?: Size;
  /** Вертикальный отступ между меню и иконкой с троеточием */
  marginTop?: string | number;
  /** Выравнивание меню относительно левого или правого края иконки с троеточием */
  alignment?: Alignment;
  /** Коллбэк на изменение значения меню. Срабатывает при клике на опцию или нажатии Enter/Space при фокусе на опции */
  onChange: (value: IOverflowMenuItem) => void;
  /** Отключение компонента */
  disabled?: boolean;
  /** Значение меню */
  value: IOverflowMenuItem | undefined;
  /** Имя класса для переоdenпределения стилей */
  className?: string;
  /** data-test-id атрибут для тестирования компонента */
  dataTestId?: string;
  /** Уникальный идентификатор меню */
  id?: string;
  /** Отключение видимости контейнера с многоточием */
  hideDropdownIndicator?: boolean;
  /** Контейнер, в котором при необходимости можно отрисовать тултип через ReactDOM.createPortal */
  tooltipContainer?: Element | null;
  /** Флаг открытия меню */
  menuIsOpen?: boolean;
  /** Ширина выпадающего меню */
  width?: string | number;
  /** Коллбэк на открытие меню */
  onOpen?: (evt?: MouseEvent<HTMLDivElement> | KeyboardEvent<HTMLDivElement>) => void;
  /** Коллбэк на закрытие меню */
  onClose?: (evt?: MouseEvent<HTMLDivElement> | KeyboardEvent<HTMLDivElement>) => void;
  /** Контейнер, в котором при необходимости можно отрисовать меню через ReactDOM.createPortal */
  menuContainer?: Element;
}

export const OverflowMenu: FC<IOverflowMenuProps> = ({
  hideDropdownIndicator = false,
  disabled,
  value,
  tooltipContainer,
  list,
  menuIsOpen,
  onOpen,
  size = 'big',
  onClose,
  width = '320px',
  onChange,
  marginTop = 0,
  alignment = 'left',
  menuContainer,
  ...props
}) => {
  const [opened, setOpened] = useState<boolean>(false);
  const [focused, setFocused] = useState<boolean>(false);
  const wrapperRef = useRef<HTMLDivElement>(null);
  const menuListRef = useRef<HTMLDivElement | null>(null);
  const menuRef = useRef<HTMLDivElement | null>(null);
  const inputRef = useRef<any>(null);
  const optionsRefs = useRef<{ [value: string]: MutableRefObject<HTMLDivElement> }>({});

  const getFocusedOption = () => {
    return ((menuListRef.current && menuListRef.current.ownerDocument) || document).activeElement;
  };

  const setInputFocused = () => {
    inputRef.current && inputRef.current.focus();
  };

  const getNumber = (value: string | number): number => {
    if (typeof value === 'string') return +value.replace(/\D+/g, '');
    else return value;
  };

  const updateState = (
    open: boolean,
    event: MouseEvent<HTMLDivElement> | KeyboardEvent<HTMLDivElement> | undefined,
    focusInput?: boolean
  ) => {
    if (open) {
      onOpen && onOpen(event);
    } else {
      focusInput && setInputFocused();
      onClose && onClose(event);
    }
    setOpened(open);
  };

  const handleOutsideClick = (event: MouseEvent<any>) => {
    opened && updateState(false, event);
    if (focused) {
      setFocused(false);
    }
  };

  useClickOutside(wrapperRef, menuRef, handleOutsideClick);

  const menuPosition = () => {
    if (inputRef.current && menuRef.current) {
      const place = getMenuPlacement(
        inputRef.current.getBoundingClientRect(),
        menuRef.current.getBoundingClientRect()
      );
      const { top } = calcMenuPosition(
        hideDropdownIndicator ? inputRef?.current?.parentNode : inputRef.current,
        menuRef.current,
        place
      );

      const topPosition = top + getNumber(marginTop);

      const overflowLeft = inputRef.current.getBoundingClientRect().left > getNumber(width);
      const overflowRight =
        inputRef.current.getBoundingClientRect().right + getNumber(width) >
        document.body.clientWidth;

      menuRef.current.style.top = `${topPosition}px`;
      const menuStyle = (left, right) => {
        if (menuRef.current) {
          menuRef.current.style.left = left === 0 ? '0px' : '';
          menuRef.current.style.right = right === 0 ? `0px` : '';
        }
      };

      if (alignment === 'left' && !overflowRight) {
        menuStyle(0, '');
      } else if (alignment === 'left' && overflowRight) {
        menuStyle('', 0);
      } else if (alignment === 'right' && overflowLeft) {
        menuStyle('', 0);
      } else {
        menuStyle(0, '');
      }
    }
  };

  useLayoutEffect(() => {
    if ((opened || menuIsOpen) && inputRef.current && menuRef.current) {
      menuPosition();
      if (optionsRefs.current[value?.value]) {
        optionsRefs.current[value?.value].current &&
          optionsRefs.current[value?.value].current.focus();
      } else {
        menuListRef.current?.firstChild && (menuListRef.current.firstChild as HTMLElement).focus();
      }
    }
  }, [opened, menuIsOpen]);

  const handleOptionClick = (newValue: any) => (event: MouseEvent<HTMLDivElement>) => {
    onChange(newValue);
    updateState(false, event, true);
  };

  const handleKeyDown = (event: KeyboardEvent<HTMLDivElement>) => {
    const focusedOption = getFocusedOption();

    const focusedOptionValue = focusedOption?.getAttribute('data-value');

    if (event.key === 'Enter' || event.key === ' ') {
      updateState(!opened, event, true);

      if (event.key === 'Enter' && (opened || menuIsOpen)) {
        if (value?.value?.toString?.() !== focusedOptionValue) {
          const option = list.filter((item) => item.value.toString() === focusedOptionValue)[0];
          onChange(option);
        }
      }
      event.preventDefault();
    }

    if (event.key === 'ArrowUp') {
      moveFocus(menuListRef.current, focusedOption, previousItem);
      event.preventDefault();
    }
    if (event.key === 'ArrowDown') {
      moveFocus(menuListRef.current, focusedOption, nextItem);
      event.preventDefault();
    }

    if (event.key === 'ArrowDown') {
      moveFocus(menuListRef.current, focusedOption, nextItem);
      event.preventDefault();
    }
    if (event.key === 'Home') {
      moveFocus(menuListRef.current, null, nextItem);
      event.preventDefault();
    }
    if (event.key === 'End') {
      moveFocus(menuListRef.current, null, previousItem);
      event.preventDefault();
    }
    if (event.key === 'Escape') {
      updateState(false, event, true);
      event.preventDefault();
    }
    if (event.key === 'Tab') {
      if (!opened && focused) {
        setFocused(false);
        return;
      }
      event.preventDefault();
      updateState(false, event, true);
    }
  };

  const handleMouseDown = (event: MouseEvent<HTMLDivElement>) => {
    if (event.button === 0 && !disabled) {
      event.preventDefault();
      setInputFocused();
      updateState(!opened, event);
    }
  };

  const renderMenu = () => (
    <DropdownMenu
      menuListRef={menuListRef}
      menuRef={menuRef}
      size={size}
      value={value}
      disabled={disabled}
      tooltipContainer={tooltipContainer}
      optionsRefs={optionsRefs}
      opened={menuIsOpen === undefined ? opened : menuIsOpen}
      list={list}
      width={width}
      onOptionClick={handleOptionClick}
      onKeyDown={handleKeyDown}
      {...props}
    />
  );

  return (
    <BaseWrapper ref={inputRef}>
      <DropDownWrapper ref={wrapperRef}>
        {!hideDropdownIndicator && (
          <IndicatorsWrapper
            tabIndex={0}
            onMouseDown={handleMouseDown}
            size={size}
            menuIsOpen={opened}
            disabled={disabled}
          >
            <IconWrapper disabled={disabled}>
              <MoreOutline width={iconSize[size]} height={iconSize[size]} />
            </IconWrapper>
          </IndicatorsWrapper>
        )}

        <WrapperDropDown>
          {(menuIsOpen === undefined ? opened : menuIsOpen) &&
            (menuContainer ? createPortal(renderMenu(), menuContainer) : renderMenu())}
        </WrapperDropDown>
      </DropDownWrapper>
    </BaseWrapper>
  );
};
