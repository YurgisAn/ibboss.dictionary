import React, { isValidElement, useEffect } from 'react';
import type { ReactNode, RefObject } from 'react';

import { SelectItem } from '../SelectItem';
import { ProductSelectItem, CardSelectItem } from '../ProductOrCardSelectItem';

import type { SelectType } from './constants';
import type { ISelectComponentItem } from './types';

export const areEqual = (a: any, b: any) => {
  if (typeof b === 'object' && b !== null) {
    return a === b;
  }

  return String(a) === String(b);
};

export const findSelectedChild = (childrenArray: ReactNode[], value: any) => {
  const selectedItems = childrenArray.filter((child: ReactNode) => {
    return isValidElement(child) && areEqual(child.props.value, value);
  });
  return selectedItems[0];
};

export const findSelectedItemList = (
  list: ISelectComponentItem[],
  value: any,
  type: SelectType
): ReactNode => {
  const selectedItems = list.filter((item: ISelectComponentItem) => {
    return areEqual(item.value, value);
  });
  if (selectedItems[0]) {
    const { label, value: itemValue, disabled, icon, image, currency, note } = selectedItems[0];
    const Icon: any = icon;
    if (type === 'card')
      return (
        <CardSelectItem
          value={itemValue}
          disabled={disabled}
          note={note}
          image={image}
          currency={currency}
        >
          {label}
        </CardSelectItem>
      );
    if (type === 'product')
      return (
        <ProductSelectItem
          value={itemValue}
          disabled={disabled}
          note={note}
          image={image}
          currency={currency}
        >
          {label}
        </ProductSelectItem>
      );
    return (
      <SelectItem value={itemValue} disabled={disabled}>
        {Icon && <Icon />}
        {label}
      </SelectItem>
    );
  }
  return null;
};

export const moveFocus = (
  list: Element | null,
  currentFocus: Element | null,
  calcNextFocus: (list: Element | null, item: Element | null) => any
) => {
  let wrappedOnce = false;
  let nextFocus = calcNextFocus(list, currentFocus);

  while (nextFocus) {
    if (nextFocus === list?.firstChild) {
      if (wrappedOnce) {
        return;
      }
      wrappedOnce = true;
    }

    if (!nextFocus.hasAttribute('tabindex') || nextFocus.hasAttribute('disabled')) {
      nextFocus = calcNextFocus(list, nextFocus);
    } else {
      nextFocus.focus();
      return;
    }
  }
};

export const nextItem = (list: Element | null, item: Element | null) => {
  if (item?.nextElementSibling) {
    return item.nextElementSibling;
  }
  return list?.firstChild;
};

export const previousItem = (list: Element | null, item: Element | null) => {
  if (item?.previousElementSibling) {
    return item.previousElementSibling;
  }
  return list?.lastChild;
};

export const useClickOutside = (
  ref: RefObject<HTMLElement>,
  menuRef: RefObject<HTMLElement>,
  handler: any
) => {
  useEffect(() => {
    const listener = (event: any) => {
      if (!ref.current || ref.current.contains(event.target)) {
        return;
      }
      if (menuRef.current?.contains(event.target)) {
        return;
      }
      handler(event);
    };
    document.addEventListener('mousedown', listener);
    document.addEventListener('touchstart', listener);
    return () => {
      document.removeEventListener('mousedown', listener);
      document.removeEventListener('touchstart', listener);
    };
  }, [ref, menuRef, handler]);
};

const VERTICAL_MARGIN = 8;

export const getMenuPlacement = (targetRect: DOMRect, menuRect: DOMRect) => {
  const { height: menuHeight } = menuRect;
  const { bottom: targetBottom } = targetRect;
  const viewPortHeight = window.innerHeight;

  if (viewPortHeight < targetBottom + menuHeight + VERTICAL_MARGIN) {
    return 'top';
  }

  return 'bottom';
};

export const calcMenuPosition = (
  target: Element,
  menu: Element,
  direction: 'bottom' | 'top' = 'bottom'
) => {
  const { height: menuHeight } = menu.getBoundingClientRect();
  const { height: targetHeight, top: targetTop, left: targetLeft } = target.getBoundingClientRect();
  const { parentTop, parentLeft } = getParentOffset(menu);

  let y: any;
  if (direction === 'top') {
    y = targetTop + window.scrollY - parentTop - menuHeight - VERTICAL_MARGIN;
  } else if (direction === 'bottom') {
    y = targetTop + window.scrollY - parentTop + targetHeight + VERTICAL_MARGIN;
  }

  return {
    left: targetLeft + window.scrollX - parentLeft,
    top: y,
  };
};

const getParentOffset = (currentTarget: Element) => {
  let currentParent = currentTarget.parentElement as Element;

  while (currentParent) {
    const computedStyle = window.getComputedStyle(currentParent);
    if (computedStyle.getPropertyValue('position') !== 'static') break;
    currentParent = currentParent.parentElement as Element;
  }
  const parentTop = currentParent?.getBoundingClientRect().top + window.scrollY || 0;
  const parentLeft = currentParent?.getBoundingClientRect().left + window.scrollX || 0;
  return { parentTop, parentLeft };
};
