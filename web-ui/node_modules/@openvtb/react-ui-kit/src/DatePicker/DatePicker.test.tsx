import React from 'react';
import { mount, ReactWrapper } from 'enzyme';

import { Calendar } from '../Calendar';
import { CalendarComponent } from '../Calendar/CalendarComponent';
import { DayComponent } from '../Calendar/DayComponent';
import { Input } from '../Inputs';
import { DatePicker } from '../DatePicker';
import { getParsedValue, getFormattedValue, valid } from '../Calendar/date-utils';

import { StyledCalendarSolidIcon } from './StyledCalendarSolidIcon';

jest.mock('../TooltipHOC', () => ({
  // eslint-disable-next-line react/display-name
  createTooltipHOC: (args: any) => args,
}));

jest.mock('../Icons/system/CalendarSolid.svg', () => ({
  // eslint-disable-next-line react/display-name
  ReactComponent: () => <div> CalendarIcon </div>,
}));

jest.mock('../common/default-theme', () => ({
  DEFAULT_THEME: {
    borderRadius: '',
    boxShadow: {},
    input: { iconPaddingTop: {} },
    color: {
      neutral: {},
      primary: {},
      opacity: {},
      error: {},
      success: {},
    },
  },
}));

const DAY_CLASS = DayComponent;

const testedDate = new Date(2020, 7, 1);
const testedDate2 = new Date(2020, 8, 19);

const getFormattedString = (value: Date): string => {
  if (valid(value)) {
    return getFormattedValue(new Date(value), 'dd/MM/yyyy', 'ru') || '';
  }
  return '';
};

const getParse = (value: string): Date => getParsedValue(value, 'dd/MM/yyyy', 'ru');

const getDateFromCalendar = (
  value: string | Date | Date[] | null,
  date: 'start' | 'end' | undefined,
  range?: boolean
): Date | null => {
  if (date && range) {
    if (Array.isArray(value)) {
      return date === 'start' ? value[0] : value[1];
    } else if (typeof value === 'string') {
      const dateStart = value?.split?.('-')[0] ? value?.split?.('-')[0].trim() : '';
      const dateEnd = value?.split?.('-')[1] ? value?.split?.('-')[1].trim() : '';
      const res = date === 'start' ? getParse(dateStart) : getParse(dateEnd);
      return res;
    }
  }
  if (typeof value === 'string') {
    const val = getParse(value);
    return val;
  } else {
    return Array.isArray(value) ? null : value;
  }
};

const formatInputValue = (value: string | Date | Date[] | null, range?: boolean): string => {
  if (typeof value === 'string') {
    return value;
  }
  if (range && Array.isArray(value)) {
    return value[1]
      ? `${getFormattedString(value[0])} - ${getFormattedString(value[1])}`
      : `${getFormattedString(value[0])}`;
  } else {
    return value instanceof Date ? getFormattedString(value) : '';
  }
};

const emptyCallback = (_: string) => {
  /* do nothing */
};

const zeroPad = (num: string | number) => String(num).padStart(2, '0');

const getInputValue = (wrapper: ReactWrapper) =>
  wrapper.find('input').getDOMNode().attributes['value'].value;

const testErrorMessage = (error: string, initialValue: string, finalValue: string, props?: any) => {
  let testValue = '';
  const wrapper = mount(
    <DatePicker onChange={(value) => (testValue = value)} value={''} {...props} />
  );
  const input = wrapper.find('input');

  input.simulate('change', { target: { value: initialValue, masked: initialValue } });

  wrapper.setProps({
    value: testValue,
  });
  input.simulate('blur');
  expect(wrapper.find(Input.Mask).find(`div[children="${error}"]`).length).toBe(1);
  input.simulate('focus');
  input.simulate('change', { target: { value: finalValue, masked: finalValue } });
  wrapper.setProps({
    value: testValue,
  });
  input.simulate('blur');

  expect(wrapper.find(Input.Mask).find(`div[children="${error}"]`).length).toBe(0);
};

describe('DatePicker', () => {
  it('should render component without opening calendar by default', () => {
    const wrapper = mount(<DatePicker value={testedDate} onChange={emptyCallback} />);
    expect(wrapper.find(CalendarComponent).length).toBe(0);
  });

  it('should open calendar after "Calendar" button has been clicked', () => {
    const wrapper = mount(<DatePicker value={testedDate} onChange={emptyCallback} />);
    wrapper.find(StyledCalendarSolidIcon).simulate('mouseDown');
    expect(wrapper.find(CalendarComponent).getDOMNode()).toBeInstanceOf(HTMLDivElement);
  });

  it('should contain correctly formatted input single value', () => {
    const wrapper = mount(<DatePicker value={testedDate} onChange={emptyCallback} />);
    expect(getInputValue(wrapper)).toBe('01.08.2020');
  });

  it('should contain correctly formatted input range value', () => {
    const wrapper = mount(
      <DatePicker range value={[testedDate, testedDate2]} onChange={emptyCallback} />
    );
    expect(getInputValue(wrapper)).toBe('01.08.2020 - 19.09.2020');
  });

  it('should contain correctly formatted input single value for Validator.invalidXXX date', () => {
    const defaultValidator = Calendar.getDefaultValidator();
    const calendarValidator = {
      ...defaultValidator,
      invalidValue: (date?: Date | null): string | null => {
        const defaultError = defaultValidator.invalidValue(date);
        if (!date) return defaultError;
        const pastDateError = date.valueOf() <= testedDate.valueOf() ? 'Дата меньше текущей' : null;
        return defaultError || pastDateError;
      },
    };
    const wrapper = mount(
      <DatePicker value={testedDate} validator={calendarValidator} onChange={emptyCallback} />
    );
    expect(getInputValue(wrapper)).toBe('01.08.2020');
  });

  it('should contain additional text for status == "error" (single, "Неверный формат даты")', () => {
    testErrorMessage('Неверный формат даты', '05.09.', '10.12.2020');
  });

  it('should contain additional text for status == "error" (single - minDate, "Дата вне диапазона")', () => {
    testErrorMessage('Дата вне диапазона', '05.09.2020', '15.09.2020', {
      minDate: new Date(2020, 8, 10),
    });
  });

  it('should contain additional text for status == "error" (single - maxDate, "Дата вне диапазона")', () => {
    testErrorMessage('Дата вне диапазона', '05.09.2020', '02.09.2020', {
      maxDate: new Date(2020, 8, 4),
    });
  });

  it('should contain additional text for status == "error" (range, "Начальная дата не валидна")', () => {
    testErrorMessage(
      'Начальная дата не валидна',
      '95.09.2020 - 14.09.2020',
      '05.09.2020 - 14.09.2020',
      { range: true }
    );
  });

  it('should contain additional text for status == "error" (range, "Конечная дата не валидна")', () => {
    testErrorMessage(
      'Конечная дата не валидна',
      '05.09.2020 - 94.09.2020',
      '05.09.2020 - 14.09.2020',
      { range: true }
    );
  });

  it('should contain additional text for status == "error" (range, "Даты не валидны")', () => {
    testErrorMessage('Даты не валидны', '95.09.2020 - 94.09.2020', '05.09.2020 - 14.09.2020', {
      range: true,
    });
  });

  it('should contain additional text for status == "error" (range, "Неверный формат дат")', () => {
    testErrorMessage('Неверный формат дат', '05.09.202 - 14.09.202', '05.09.2020 - 14.09.2020', {
      range: true,
    });
  });

  it('should contain additional text for status == "error" (range, "Конечная дата меньше начальной")', () => {
    testErrorMessage(
      'Конечная дата меньше начальной',
      '05.09.2020 - 04.09.2020',
      '05.09.2020 - 06.09.2020',
      { range: true }
    );
  });

  it('should set endDate to "undeifned', () => {
    const firstDayItemNumber = 8;
    const dayItemOffset = 10;
    const currentMonth = new Date().getMonth();
    const currentYear = new Date().getFullYear();
    let startDay = '';
    let endDay = '';

    const wrapper = mount(
      <DatePicker
        range
        value=""
        calendarIsOpen
        onChange={(date: string) => {
          startDay = date?.split('-')[0]?.trim();
          endDay = date?.split('-')[1]?.trim();
        }}
      />
    );
    const dayElements = wrapper.find(DAY_CLASS);
    const firstDay = parseInt(dayElements.at(firstDayItemNumber).text());
    const test = `${zeroPad(firstDay)}.${zeroPad(currentMonth + 1)}.${currentYear}`;
    const input = wrapper.find('input');
    input.simulate('change', { target: { value: test, masked: test } });
    expect(startDay).toBe(test);
    expect(endDay).toBeUndefined();
    wrapper.setProps({
      value: startDay,
    });

    wrapper.find(StyledCalendarSolidIcon).simulate('mouseDown');

    dayElements.at(firstDayItemNumber).simulate('mouseDown');
    dayElements.at(firstDayItemNumber + dayItemOffset).simulate('mouseDown');

    wrapper.setProps({
      value: `${startDay}` + `${endDay}`,
    });
    expect(getInputValue(wrapper)).toBe(
      `${zeroPad(firstDay)}.${zeroPad(currentMonth + 1)}.${currentYear} - ${zeroPad(
        firstDay + dayItemOffset
      )}.${zeroPad(currentMonth + 1)}.${currentYear}`
    );
  });

  it('should set only end date of [startDate, endDate] to "null" and allow to set end date inside the calendar when input end date is invalid', () => {
    let startDay = '';
    let endDay = '';
    const wrapper = mount(
      <DatePicker
        range
        value={new Date()}
        onChange={(date: string) => {
          startDay = date?.split('-')[0]?.trim();
          endDay = date?.split('-')[1]?.trim();
        }}
      />
    );

    const input = wrapper.find('input');
    input.simulate('change', { target: { value: '05.09.2020', masked: '05.09.2020' } });
    expect(startDay).toBe('05.09.2020');
    expect(endDay).toBeUndefined();
    wrapper.setProps({
      value: startDay,
    });

    expect(getInputValue(wrapper)).toBe('05.09.2020');
    wrapper.find(StyledCalendarSolidIcon).simulate('mouseDown');
    const dayElement = wrapper.find(DAY_CLASS);
    dayElement.at(15).simulate('mouseDown');
    wrapper.setProps({
      value: `${startDay} - ${endDay}`,
    });
    expect(startDay).toEqual('05.09.2020');
    expect(endDay).toEqual('15.09.2020');

    expect(getInputValue(wrapper)).toBe('05.09.2020 - 15.09.2020');
  });

  it('should have selected calendar date', () => {
    const wrapper = mount(<DatePicker value={new Date(2020, 1, 29)} onChange={emptyCallback} />);
    wrapper.find(StyledCalendarSolidIcon).simulate('mouseDown');

    const dayElements = wrapper.find(DAY_CLASS);

    const selectedDayElement = dayElements.at(33);
    expect(selectedDayElement.text()).toBe('29');
  });

  it('should change day when new day has been clicked', () => {
    let clickedDay = '';
    const wrapper = mount(
      <DatePicker
        value={testedDate}
        onChange={(date: string) => {
          clickedDay = date;
        }}
      />
    );

    const input = wrapper.find('input');
    input.simulate('change', { target: { value: '01.08.2020', masked: '01.08.2020' } });

    wrapper.setProps({
      value: clickedDay,
    });

    expect(getInputValue(wrapper)).toBe('01.08.2020');
    wrapper.find(StyledCalendarSolidIcon).simulate('mouseDown');

    const dayElement = wrapper.find(DAY_CLASS);
    expect(dayElement.length).toBe(7 * 6);

    dayElement.at(20).simulate('mouseDown');
    expect(clickedDay).toEqual('16.08.2020');
    wrapper.setProps({
      value: clickedDay,
    });
    expect(getInputValue(wrapper)).toBe('16.08.2020');
  });

  it('should change days range when start and end days have been clicked', () => {
    let testRange = '';
    const wrapper = mount(
      <DatePicker
        value={[testedDate, testedDate]}
        range
        onChange={(date: string) => {
          testRange = date;
        }}
      />
    );
    wrapper.find(StyledCalendarSolidIcon).simulate('mouseDown');

    const dayElement = wrapper.find(DAY_CLASS);
    expect(dayElement.length).toBe(7 * 6);

    dayElement.at(20).simulate('mouseDown');

    expect(testRange).toEqual('16.08.2020');

    wrapper.setProps({
      value: testRange,
    });
    expect(getInputValue(wrapper)).toBe('16.08.2020');

    dayElement.at(25).simulate('mouseDown');
    wrapper.setProps({
      value: testRange,
    });

    expect(testRange).toEqual('16.08.2020 - 21.08.2020');

    expect(getInputValue(wrapper)).toBe('16.08.2020 - 21.08.2020');
  });

  it('should change day when add handleParseInputValue, getDateFromCalendar, and prop mask custom  new day has been clicked', () => {
    let test = '';
    const wrapper = mount(
      <DatePicker
        value={testedDate}
        mask={'99/99/9999'}
        getDateFromCalendar={getDateFromCalendar}
        formatInputValue={formatInputValue}
        onChange={(date: string) => {
          test = date;
        }}
      />
    );
    const input = wrapper.find('input');
    input.simulate('change', { target: { value: '01082020', masked: '01082020' } });

    wrapper.setProps({
      value: test,
    });

    expect(getInputValue(wrapper)).toBe('01/08/2020');
    wrapper.find(StyledCalendarSolidIcon).simulate('mouseDown');

    const dayElement = wrapper.find(DAY_CLASS);
    expect(dayElement.length).toBe(7 * 6);

    dayElement.at(20).simulate('mouseDown');
    expect(test).toEqual('16/08/2020');
    wrapper.setProps({
      value: test,
    });
    expect(getInputValue(wrapper)).toBe('16/08/2020');
  });

  it('should change range when add handleParseInputValue, getDateFromCalendar, and prop mask 99/99/9999 - 99/99/9999', () => {
    let testRange = '';

    const wrapper = mount(
      <DatePicker
        range
        value={[testedDate, testedDate]}
        mask={'99/99/9999 - 99/99/9999'}
        getDateFromCalendar={getDateFromCalendar}
        onChange={(date: string) => {
          testRange = date;
        }}
        formatInputValue={formatInputValue}
      />
    );
    wrapper.find(StyledCalendarSolidIcon).simulate('mouseDown');

    const dayElement = wrapper.find(DAY_CLASS);
    expect(dayElement.length).toBe(7 * 6);

    dayElement.at(20).simulate('mouseDown');

    expect(testRange).toEqual('16/08/2020');

    wrapper.setProps({
      value: testRange,
    });
    expect(getInputValue(wrapper)).toBe('16/08/2020');

    dayElement.at(25).simulate('mouseDown');
    wrapper.setProps({
      value: testRange,
    });

    expect(testRange).toEqual('16/08/2020 - 21/08/2020');

    expect(getInputValue(wrapper)).toBe('16/08/2020 - 21/08/2020');
  });
});
