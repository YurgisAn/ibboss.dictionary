import React, { Component, createRef, RefObject, FocusEvent, SyntheticEvent } from 'react';
import ReactDOM from 'react-dom';

import type { IDateSelectionProps, ICalendarProps } from '../Calendar';
import type { IInputMaskProps } from '../Inputs';
import { Calendar } from '../Calendar';
import { Input } from '../Inputs';
import { getDefaultDateValidator } from '../Calendar/Validator';
import { getFormattedValue, getParsedValue, valid, outOfBounds } from '../Calendar/date-utils';
import { getScrollableParents, getContainingBlockOffset } from '../common/utils';
import { getIconSize } from '../Inputs/common';
import { ReactComponent as CalendarSolid } from '../Icons/system/CalendarSolid.svg';

import { CALENDAR_SIZES, DEFAULT_DATE_FORMAT } from './constants';
import { DatePickerComponent } from './DatePickerComponent';
import { DatePickerInputComponent } from './DatePickerInputComponent';
import { CalendarPopupComponent } from './CalendarPopupComponent';
import { StyledCalendarSolidIcon } from './StyledCalendarSolidIcon';

type CalendarSize = ICalendarProps['size'];

type IDatePickerInputMaskProps = Omit<IInputMaskProps, 'value'>;

export interface IDatePickerProps extends IDateSelectionProps, IDatePickerInputMaskProps {
  /** Коллбэк выбора даты, срабатывает при клике на дне или годе (в режиме диапазона date - это массив из двух дат) */
  onChange: (value: string) => void;
  /* Значение DatePicker */
  value: string | Date | Date[] | null;
  /** Ширина инпута (по умолчанию используется ширина календаря) */
  width?: string | number;
  /** Размер календаря */
  calendarSize?: CalendarSize;
  /** Коллбэк обработки открытия календаря */
  onShow?: () => void;
  /** Коллбэк обработки закрытия календаря */
  onHide?: () => void;
  /** Коллбэк обработки выбора даты */
  onDateSelected?: () => void;
  /** Контейнер, в котором происходит размещение выпадающего календаря */
  calendarContainer?: Element;
  /** Флаг для открывания календаря */
  calendarIsOpen?: boolean;
  /** Коллбек парсит строку для получения даты для календаря */
  getDateFromCalendar?: (
    value: string | Date | Date[] | null,
    date?: 'start' | 'end',
    range?: boolean
  ) => Date | null;
  /** Коллбек для изменения input value. Cейчас формат 11.11.1111 */
  formatInputValue?: (value: string | Date | Date[] | null, range?: boolean) => string;
}

interface IState {
  visible?: boolean;
  focused?: boolean;
  error?: string | null;
  posX: number;
  posY: number;
  mask: string;
}

export class DatePicker extends Component<IDatePickerProps, IState> {
  static defaultProps: Partial<IDatePickerProps> = {
    placeholder: '',
  };

  refInput: RefObject<HTMLInputElement> = createRef();
  refDatePicker: RefObject<HTMLDivElement> = createRef();
  refCalendar: RefObject<any> = createRef();
  scrollableParents?: Array<Element> = undefined;

  state: IState = {
    visible: false,
    focused: false,
    error: null,
    posX: 0,
    mask: this.props.mask
      ? this.props.mask
      : this.props.range
      ? '99.99.9999 - 99.99.9999'
      : '99.99.9999',
    posY: 0,
  };

  componentDidMount() {
    window.addEventListener('scroll', this.onHide);
    window.addEventListener('resize', this.onHide);
    this.changePosition();
  }
  componentWillUnmount() {
    this.scrollableParents &&
      this.scrollableParents.forEach((el) => el.removeEventListener('scroll', this.onHide));
    window.removeEventListener('scroll', this.onHide);
    window.removeEventListener('resize', this.onHide);
  }
  componentDidUpdate(_: IDatePickerProps, prevState: IState) {
    if (!this.scrollableParents && this.refDatePicker.current) {
      this.scrollableParents = getScrollableParents(this.refDatePicker.current);
      this.scrollableParents?.forEach((el) => el.addEventListener('scroll', this.onHide));
    }
    if (prevState.visible === this.state.visible) return;
    this.changePosition();
  }

  changePosition = () => {
    if (!this.state.visible && !this.props.calendarIsOpen) return;
    const calendarNode = this.refCalendar.current;
    const targetNode = this.refInput.current;
    if (!calendarNode || !targetNode) return;

    const targetRect = targetNode.getBoundingClientRect();
    const { parentTop, parentLeft } = getContainingBlockOffset(calendarNode);
    this.setState({
      posX: targetRect.left - parentLeft,
      posY: targetRect.height + targetRect.top - parentTop,
    });
  };

  getValidator() {
    return this.props.validator || getDefaultDateValidator(this.props.minDate, this.props.maxDate);
  }

  handleToggleVisible = (e: React.MouseEvent<HTMLDivElement>) => {
    const { visible } = this.state;
    this.refInput.current?.focus();

    this.setState({
      visible: !visible,
    });
  };

  handleChangeValue = (date: Date | null, event?: SyntheticEvent<any>) => {
    const { onDateSelected } = this.props;
    // calendar change
    if (event && !this.props.calendarIsOpen) {
      this.setState({
        visible: false,
      });
    }

    this.handleChangeInput({
      value: this.handleParseInputValue(date),
      masked: this.handleParseInputValue(date),
    });
    onDateSelected && onDateSelected();
  };

  handleChangeRange = (dates: Date[] | null, event?: SyntheticEvent<any>) => {
    const dateStart = dates ? dates[0] : null,
      dateEnd = dates ? dates[1] : null;
    const rangeSelected = dateStart && dateEnd;

    // calendar change
    if (event) {
      this.handleChangeInput({
        value: this.handleParseInputValue(dates),
        masked: this.handleParseInputValue(dates),
      });
      this.setState({
        visible: !rangeSelected,
      });
    }
  };

  handleChangeInput = (value: { value: string; masked: string }) => {
    this.setState({
      error: null,
      visible: false,
    });

    this.props.onChange(this.handleParseInputValue(value.masked));
  };

  getDate = (value: string): Date => {
    return getParsedValue(value, DEFAULT_DATE_FORMAT, this.props.localeName);
  };

  onHide = () => {
    this.setState({
      visible: false,
    });
  };

  onFocus = (event: FocusEvent<HTMLInputElement>) => {
    this.props.onFocus?.(event);
    this.setState({ focused: true });
  };

  onBlur = (event: FocusEvent<HTMLInputElement>) => {
    this.props.onBlur?.(event);
    const { value } = this.props;
    const { error } = this.state;
    const validator = this.getValidator();
    let currentError: string | null = null;
    if (this.props.range) {
      const startDate = value ? this.getDateFromCalendar(value, 'start') : null;
      const endDate = value ? this.getDateFromCalendar(value, 'end') : null;
      currentError =
        this.handleParseInputValue(value)?.length < this.state.mask.length
          ? validator.invalidRange(null, null)
          : validator.invalidRange(startDate, endDate);
    } else {
      currentError =
        value &&
        validator.invalidValue(
          this.handleParseInputValue(value).length < this.state.mask.length
            ? null
            : this.getDateFromCalendar(value)
        );
    }

    this.setState({
      visible: false,
      focused: false,
      error: error || currentError,
    });
  };

  getFormattedString = (value: Date): string => {
    if (valid(value)) {
      return getFormattedValue(new Date(value), DEFAULT_DATE_FORMAT, this.props.localeName) || '';
    }
    return '';
  };

  getDateFromCalendar = (
    value: string | Date | Date[] | null,
    date?: 'start' | 'end'
  ): Date | null => {
    if (this.props.getDateFromCalendar) {
      return this.props.getDateFromCalendar(value, date, this.props.range);
    } else {
      if (date && this.props.range) {
        if (Array.isArray(value)) {
          return date === 'start' ? value[0] : value[1];
        } else if (typeof value === 'string') {
          const dateStart = value?.split?.('-')[0] ? value?.split?.('-')[0].trim() : '';
          const dateEnd = value?.split?.('-')[1] ? value?.split?.('-')[1].trim() : '';
          const res = date === 'start' ? this.getDate(dateStart) : this.getDate(dateEnd);
          return res;
        }
      }
      if (typeof value === 'string') {
        const val = this.getDate(value.trim());
        return val;
      } else {
        return Array.isArray(value) ? null : value;
      }
    }
  };

  handleParseInputValue = (value: string | Date | Date[] | null): string => {
    if (this.props.formatInputValue) {
      return this.props.formatInputValue(value, this.props.range);
    } else {
      if (typeof value === 'string') {
        return value;
      }
      if (this.props.range && Array.isArray(value)) {
        return value[1]
          ? `${this.getFormattedString(value[0])} - ${this.getFormattedString(value[1])}`
          : `${this.getFormattedString(value[0])}`;
      } else {
        return value instanceof Date ? this.getFormattedString(value) : '';
      }
    }
  };

  getStatus = (value, status, errorMessage) => {
    if (status) return status;
    else if (errorMessage && !status && value) return 'error';
    else return 'default';
  };

  getAdditionalText = (value, additionalText, errorMessage) => {
    if (additionalText) return additionalText;
    else if (errorMessage && !additionalText && value) return errorMessage;
    else '';
  };

  renderCalendar() {
    const { calendarSize = 'big', range, value, minDate, maxDate, ...props } = this.props;
    const { posX, posY } = this.state;

    const validDate = (date) => {
      if (range && valid(this.getDateFromCalendar(value, date)))
        return this.getDateFromCalendar(value, date);
      else return null;
    };
    const startDate = validDate('start');

    const endDate = validDate('end');

    const date =
      !range && valid(this.getDateFromCalendar(value)) ? this.getDateFromCalendar(value) : null;

    return (
      <CalendarPopupComponent ref={this.refCalendar} position={{ X: posX, Y: posY }}>
        <Calendar
          {...props}
          simple
          size={calendarSize}
          range={range}
          selected={date && !outOfBounds(date, minDate, maxDate) ? date : null}
          minDate={minDate}
          maxDate={maxDate}
          startDate={startDate && !outOfBounds(startDate, minDate, maxDate) ? startDate : null}
          endDate={endDate && !outOfBounds(endDate, minDate, maxDate) ? endDate : null}
          validator={this.getValidator()}
          onChange={range ? this.handleChangeRange : this.handleChangeValue}
        />
      </CalendarPopupComponent>
    );
  }

  render() {
    const {
      size = 'big',
      calendarSize = 'big',
      width = this.props.width || CALENDAR_SIZES[calendarSize],
      disabled,
      className,
      dataTestId,
      calendarContainer,
      icon,
      status,
      additionalText,
      value,
      calendarIsOpen,
      ...props
    } = this.props;
    const { visible, focused, error } = this.state;
    const iconSize = getIconSize(size);

    const errorMessage = !focused ? error : undefined;
    const shouldRenderCalendar = calendarIsOpen ? calendarIsOpen : visible;
    const iconServices = (
      <StyledCalendarSolidIcon
        disabled={disabled}
        active={visible}
        onMouseDown={(e) => {
          e.preventDefault();
          !disabled && this.handleToggleVisible(e);
        }}
      >
        <CalendarSolid width={iconSize} height={iconSize} />
      </StyledCalendarSolidIcon>
    );

    return (
      <DatePickerComponent
        ref={this.refDatePicker}
        width={width}
        className={className}
        data-test-id={dataTestId}
      >
        <DatePickerInputComponent>
          <Input.Mask
            {...props}
            refInput={this.refInput}
            width={'100%'}
            mask={this.state.mask}
            value={this.handleParseInputValue(value)}
            size={size}
            status={this.getStatus(value, status, errorMessage)}
            additionalText={this.getAdditionalText(value, additionalText, errorMessage)}
            icon={icon || iconServices}
            disabled={disabled}
            onFocus={this.onFocus}
            onBlur={this.onBlur}
            onChange={this.handleChangeInput}
          />
        </DatePickerInputComponent>
        {shouldRenderCalendar &&
          (calendarContainer
            ? ReactDOM.createPortal(this.renderCalendar(), calendarContainer)
            : this.renderCalendar())}
      </DatePickerComponent>
    );
  }
}
