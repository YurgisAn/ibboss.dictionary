((e,t)=>{'object'==typeof exports&&'undefined'!=typeof module?t(exports):'function'==typeof define&&define.amd?define(['exports'],t):t((e='undefined'!=typeof globalThis?globalThis:e||self).effector={})})(this,(e=>{function t(e,t){for(let r in e)t(e[r],r)}function r(e,t){e.forEach(t)}function a(e,t){if(!e)throw Error(t)}function n(e,t){se={parent:se,value:e,template:L(e,'template')||fe(),sidRoot:L(e,'sidRoot')||se&&se.sidRoot};try{return t()}finally{se=T(se)}}function i({node:e=[],from:t,source:a,parent:n=t||a,to:i,target:o,child:l=i||o,scope:s={},meta:f={},family:d={type:'regular'},regional:u}={}){let c=ce(n),p=ce(d.links),m=ce(d.owners),h=[];r(e,(e=>e&&re(h,e)));let g={id:le(),seq:h,next:ce(l),meta:f,scope:s,family:{type:d.type||$,links:p,owners:m}};return r(p,(e=>re(D(e),g))),r(m,(e=>re(R(e),g))),r(c,(e=>re(e.next,g))),u&&se&&ue(P(se),[g]),g}function o(e,t,a){let n=Je,i=null,o=We;if(e.target&&(t=e.params,a=e.defer,n='page'in e?e.page:n,e.stack&&(i=e.stack),o=B(e)||o,e=e.target),o&&We&&o!==We&&(We=null),Array.isArray(e))for(let r=0;r<e.length;r++)Ve('pure',n,E(e[r]),i,t[r],o);else Ve('pure',n,E(e),i,t,o);if(a&&!He)return;let l,s,f,d,u,c,p={isRoot:He,currentPage:Je,scope:We,isWatch:Ue,isPure:Ge};He=0;e:for(;d=Pe();){let{idx:e,stack:t,type:a}=d;f=t.node,Je=u=t.page,We=B(t),u?c=u.reg:We&&(c=We.reg);let n=!!u,i=!!We,o={fail:0,scope:f.scope};l=s=0;for(let r=e;r<f.seq.length&&!l;r++){let d=f.seq[r];if(d.order){let{priority:n,barrierID:i}=d.order,o=i?u?`${u.fullID}_${i}`:i:0;if(r!==e||a!==n){i?Le.has(o)||(Le.add(o),Te(r,t,n,i)):Te(r,t,n);continue e}i&&Le.delete(o)}switch(d.type){case'mov':{let e,r=d.data;switch(r.from){case N:e=P(t);break;case F:case'b':e=t[r.from];break;case I:e=r.store;break;case S:if(c&&!c[r.store.id])if(n){let e=Xe(u,r.store.id);t.page=u=e,e?c=e.reg:i?(et(We,r.store,0,1,r.softRead),c=We.reg):c=void 0}else i&&et(We,r.store,0,1,r.softRead);e=qe(c&&c[r.store.id]||r.store)}switch(r.to){case N:t.value=e;break;case F:case'b':t[r.to]=e;break;case S:Ye(u,We,f,r.target).current=e}break}case'compute':let e=d.data;if(e.fn){Ue='watch'===L(f,'op'),Ge=e.pure;let r=e.safe?(0,e.fn)(P(t),o.scope,t):tt(o,e.fn,t);e.filter?s=!r:t.value=r,Ue=p.isWatch,Ge=p.isPure}}l=o.fail||s}if(!l){let e=P(t),a=B(t);if(r(f.next,(r=>{Ve('child',u,r,t,e,a)})),a){L(f,'needFxCounter')&&Ve('child',u,a.fxCount,t,e,a),L(f,'storeChange')&&Ve('child',u,a.storeChange,t,e,a),L(f,'warnSerialize')&&Ve('child',u,a.warnSerializeNode,t,e,a);let n=a.additionalLinks[f.id];n&&r(n,(r=>{Ve('child',u,r,t,e,a)}))}}}He=p.isRoot,Je=p.currentPage,We=B(p)}function l(e,r="combine"){let a=r+'(',n='',i=0;return t(e,(e=>{i<25&&(null!=e&&(a+=n,a+=U(e)?H(e).fullName:e.toString()),i+=1,n=', ')})),a+')'}function s(e,t){let r,a,n=e;if(t){let n=H(t);0===e.length?(r=n.path,a=n.fullName):(r=n.path.concat([e]),a=0===n.fullName.length?e:n.fullName+'/'+e)}else r=0===e.length?[]:[e],a=e;return{shortName:n,fullName:a,path:r}}function f(e,t){let r=t?e:e[0];ge(r);let a=r.or,n=r.and;if(n){let r=t?n:n[0];if(pe(r)&&'and'in r){let r=f(n,t);e=r[0],a={...a,...r[1]}}else e=n}return[e,a]}function d(e,...t){let r=fe();if(r){let a=r.handlers[e];if(a)return a(r,...t)}}function u(e,t){let r=rt({or:t,and:'string'==typeof e?{name:e}:e}),a=(e,...t)=>(ae(!L(a,'derived'),'call of derived event','createEvent'),ae(!Ge,'unit call from pure function','operators like sample'),Je?((e,t,r,a)=>{let n=Je,i=null;if(t)for(i=Je;i&&i.template!==t;)i=T(i);Qe(i);let o=e.create(r,a);return Qe(n),o})(a,n,e,t):a.create(e,t)),n=fe(),l=Object.assign(a,{graphite:i({meta:ct(x,a,r),regional:1}),create:e=>(o({target:a,params:e,scope:We}),e),watch:e=>dt(a,e),map:e=>pt(a,A,e,[Ne()]),filter:e=>pt(a,"filter",e.fn?e:e.fn,[Ne(Se,1)]),filterMap:e=>pt(a,'filterMap',e,[Ne(),$e((e=>!he(e)),1)]),prepend(e){let t=u('* \u2192 '+a.shortName,{parent:T(a)});return d('eventPrepend',E(t)),ft(t,a,[Ne()],'prepend',e),ut(a,t),t}});return null!=r&&r.domain&&r.domain.hooks.event(l),l}function c(e,t){let n=rt(t),l=Ie(e),s=u({named:'updates',derived:1});d('storeBase',l);let f=l.id,p={subscribers:new Map,updates:s,defaultState:e,stateRef:l,getState(){let e,t=l;if(Je){let t=Je;for(;t&&!t.reg[f];)t=T(t);t&&(e=t)}return!e&&We&&(et(We,l,1),e=We),e&&(t=e.reg[f]),qe(t)},setState:e=>o({target:p,params:e,defer:1,scope:We}),reset:(...e)=>(r(e,(e=>p.on(e,(()=>p.defaultState)))),p),on:(e,t)=>(be(e,'.on','first argument'),a(me(t),'second argument should be a function'),ae(!L(p,'derived'),'.on in derived store','createStore'),r(Array.isArray(e)?e:[e],(e=>{p.off(e),V(p).set(e,st(mt(e,p,'on',we,t)))})),p),off(e){let t=V(p).get(e);return t&&(t(),V(p).delete(e)),p},map(e,t){let r,a;pe(e)&&(r=e,e=e.fn),ae(he(t),'second argument of store.map','updateFilter');let n=p.getState();fe()?a=null:he(n)||(a=e(n,t));let i=c(a,{name:`${p.shortName} \u2192 *`,derived:1,and:r}),o=mt(p,i,A,ke,e);return Fe(_(i),{type:A,fn:e,from:l}),_(i).noInit=1,d('storeMap',l,o),i},watch(e,t){if(!t||!U(e)){let t=dt(p,e);return d('storeWatch',l,e)||e(p.getState()),t}return a(me(t),'second argument should be a function'),e.watch((e=>t(p.getState(),e)))}},m=ct(S,p,n),h=p.defaultConfig.updateFilter;p.graphite=i({scope:{state:l,fn:h},node:[$e(((e,t,r)=>(r.scope&&!r.scope.reg[l.id]&&(r.b=1),e))),Ae(l),$e(((e,t,{a:r,b:a})=>!he(e)&&(e!==r||a)),1),h&&Ne(ke,1),ze({from:N,target:l})],child:s,meta:m,regional:1});let g=L(p,'serialize'),y=L(p,'derived'),b='ignore'===g,v=!g||b?0:g,k=L(p,'sid');return k&&(b||W(p,'storeChange',1),l.sid=k,v&&(l.meta={...null==l?void 0:l.meta,serialize:v})),k||b||y||W(p,'warnSerialize',1),a(y||!he(e),"current state can't be undefined, use null instead"),ue(p,[s]),null!=n&&n.domain&&n.domain.hooks.store(p),y||(p.reinit=u(),p.reset(p.reinit)),p}function p(...e){let t,r,n;[e,n]=f(e);let i,o,l,s=e[e.length-1];if(me(s)?(r=e.slice(0,-1),t=s):r=e,1===r.length){let e=r[0];J(e)||(i=e,o=1)}if(!o&&(i=r,t)){l=1;let e=t;t=t=>e(...t)}return a(pe(i),'shape should be an object'),ht(Array.isArray(i),!l,i,n,t)}function m(){let e={};return e.req=new Promise(((t,r)=>{e.rs=t,e.rj=r})),e.req.catch((()=>{})),e}function h(e,t){let r=rt(me(e)?{handler:e}:e,t),n=u(me(e)?{handler:e}:e,t),l=E(n);W(l,'op',n.kind=j),n.use=e=>(a(me(e),'.use argument should be a function'),g.scope.handler=e,n),n.use.getCurrent=()=>g.scope.handler;let s=n.finally=u({named:'finally',derived:1}),f=n.done=s.filterMap({named:'done',fn({status:e,params:t,result:r}){if('done'===e)return{params:t,result:r}}}),d=n.fail=s.filterMap({named:'fail',fn({status:e,params:t,error:r}){if('fail'===e)return{params:t,error:r}}}),p=n.doneData=f.map({named:'doneData',fn:({result:e})=>e}),h=n.failData=d.map({named:'failData',fn:({error:e})=>e}),g=i({scope:{handlerId:L(l,'sid'),handler:n.defaultConfig.handler||(()=>a(0,`no handler used in ${n.getType()}`))},node:[$e(((e,t,r)=>{let a=t,n=a.handler;if(B(r)){let e=B(r).handlers[a.handlerId];e&&(n=e)}return e.handler=n,e}),0,1),$e((({params:e,req:t,handler:r,args:a=[e]},n,i)=>{let o=yt(i),l=bt(e,t,1,s,i,o),f=bt(e,t,0,s,i,o),[d,u]=gt(r,f,a);d&&(pe(u)&&me(u.then)?u.then(l,f):l(u))}),0,1)],meta:{op:'fx',fx:'runner'}});l.scope.runner=g,re(l.seq,$e(((e,{runner:t},r)=>{let a=T(r)?{params:e,req:{rs(e){},rj(e){}}}:e;return o({target:t,params:a,defer:1,scope:B(r)}),a.params}),0,1)),n.create=e=>{let t=m(),r={params:e,req:t};if(We){if(!Ue){let e=We;t.req.finally((()=>{Ke(e)})).catch((()=>{}))}o({target:n,params:r,scope:We})}else o(n,r);return t.req};let y=n.inFlight=c(0,{serialize:'ignore'}).on(n,(e=>e+1)).on(s,(e=>e-1)).map({fn:e=>e,named:'inFlight'});W(s,'needFxCounter','dec'),W(n,'needFxCounter',1);let b=n.pending=y.map({fn:e=>e>0,named:'pending'});return ue(n,[s,f,d,p,h,b,y]),null!=r&&r.domain&&r.domain.hooks.effect(n),n}function g(e,t){be(e,'merge','first argument');let r=u({name:l(e,'merge'),derived:1,and:t});return ft(e,r,[],'merge'),r}function y(e,t){let n=0;return r(kt,(r=>{r in e&&(a(null!=e[r],wt(t,r)),n=1)})),n}function b(e,t){let a=[];(function e(n){ee(a,n)||(re(a,n),L(n,'op')===S&&L(n,'sid')&&t(n,L(n,'sid')),r(n.next,e),r(D(n),e),r(R(n),e))})(e)}function v(e,t){let n=Array.isArray(e)?new Map(e):e;if(n instanceof Map){let e={};return r(n,((r,n)=>{a(U(n),'Map key should be a unit'),t&&t(n,r),a(n.sid,'unit should have a sid'),a(!(n.sid in e),'duplicate sid found'),e[n.sid]=r})),e}return n}function k(e){let t=()=>e();return t.unsubscribe=()=>e(),t}let w='undefined'!=typeof Symbol&&Symbol.observable||'@@observable',S='store',x='event',j='effect',z='domain',M='scope',C='sampler',$='crosslink',A='map',N='stack',O='barrier',I='value',q='sample',F='a',E=e=>e.graphite||e,D=e=>e.family.owners,R=e=>e.family.links,_=e=>e.stateRef,P=e=>e.value,V=e=>e.subscribers,T=e=>e.parent,B=e=>e.scope,L=(e,t)=>E(e).meta[t],W=(e,t,r)=>E(e).meta[t]=r,H=e=>e.compositeName,U=e=>(me(e)||pe(e))&&'kind'in e;const G=e=>t=>U(t)&&t.kind===e;let J=G(S),K=G(x),Q=G(j),X=G(z),Y=G(M);var Z={__proto__:null,unit:U,store:J,event:K,effect:Q,domain:X,scope:Y,attached:e=>Q(e)&&1==L(e,'attached')};let ee=(e,t)=>e.includes(t),te=(e,t)=>{let r=e.indexOf(t);-1!==r&&e.splice(r,1)},re=(e,t)=>e.push(t),ae=(e,t,r)=>!e&&console.error(`${t} is deprecated${r?`, use ${r} instead`:''}`);const ne=()=>{let e=0;return()=>""+ ++e};let ie=ne(),oe=ne(),le=ne(),se=null,fe=()=>se&&se.template,de=e=>(e&&se&&se.sidRoot&&(e=`${se.sidRoot}|${e}`),e),ue=(e,t)=>{let a=E(e);r(t,(e=>{let t=E(e);a.family.type!==z&&(t.family.type=$),re(D(t),a),re(R(a),t)}))},ce=(e=[])=>(Array.isArray(e)?e:[e]).flat().map(E),pe=e=>'object'==typeof e&&null!==e,me=e=>'function'==typeof e,he=e=>void 0===e,ge=e=>a(pe(e)||me(e),'expect first argument be an object');const ye=(e,t,r,n)=>a(!(!pe(e)&&!me(e)||!('family'in e)&&!('graphite'in e)),`${t}: expect ${r} to be a unit (store, event or effect)${n}`);let be=(e,t,a)=>{Array.isArray(e)?r(e,((e,r)=>ye(e,t,`${r} item of ${a}`,''))):ye(e,t,a,' or array of units')},ve=(e,t,a="target")=>r(ce(t),(t=>ae(!L(t,'derived'),`${e}: derived unit in "${a}"`,"createEvent/createStore"))),ke=(e,{fn:t},{a:r})=>t(e,r),we=(e,{fn:t},{a:r})=>t(r,e),Se=(e,{fn:t})=>t(e);const xe=(e,t,r,a)=>{let n={id:oe(),type:e,data:t};return r&&(n.order={priority:r},a&&(n.order.barrierID=++je)),n};let je=0,ze=({from:e=S,store:t,target:r,to:a=(r?S:N),batch:n,priority:i})=>xe('mov',{from:e,store:t,to:a,target:r},i,n),Me=({fn:e,batch:t,priority:r,safe:a=0,filter:n=0,pure:i=0})=>xe('compute',{fn:e,safe:a,filter:n,pure:i},r,t),Ce=({fn:e})=>Me({fn:e,priority:j}),$e=(e,t,r)=>Me({fn:e,safe:1,filter:t,priority:r&&j}),Ae=(e,t,r)=>ze({store:e,to:t?N:F,priority:r&&C,batch:1}),Ne=(e=Se,t)=>Me({fn:e,pure:1,filter:t}),Oe={mov:ze,compute:Me,filter:({fn:e,pure:t})=>Me({fn:e,filter:1,pure:t}),run:Ce},Ie=e=>({id:oe(),current:e}),qe=({current:e})=>e,Fe=(e,t)=>{e.before||(e.before=[]),re(e.before,t)},Ee=null;const De=(e,t)=>{if(!e)return t;if(!t)return e;let r;return(e.v.type===t.v.type&&e.v.id>t.v.id||Be(e.v.type)>Be(t.v.type))&&(r=e,e=t,t=r),r=De(e.r,t),e.r=e.l,e.l=r,e},Re=[];let _e=0;for(;_e<6;)re(Re,{first:null,last:null,size:0}),_e+=1;const Pe=()=>{for(let e=0;e<6;e++){let t=Re[e];if(t.size>0){if(3===e||4===e){t.size-=1;let e=Ee.v;return Ee=De(Ee.l,Ee.r),e}1===t.size&&(t.last=null);let r=t.first;return t.first=r.r,t.size-=1,r.v}}},Ve=(e,t,r,a,n,i)=>Te(0,{a:null,b:null,node:r,parent:a,value:n,page:t,scope:i},e),Te=(e,t,r,a=0)=>{let n=Be(r),i=Re[n],o={v:{idx:e,stack:t,type:r,id:a},l:null,r:null};3===n||4===n?Ee=De(Ee,o):(0===i.size?i.first=o:i.last.r=o,i.last=o),i.size+=1},Be=e=>{switch(e){case'child':return 0;case'pure':return 1;case'read':return 2;case O:return 3;case C:return 4;case j:return 5;default:return-1}},Le=new Set;let We,He=1,Ue=0,Ge=0,Je=null,Ke=e=>{We=e},Qe=e=>{Je=e};const Xe=(e,t)=>{if(e){for(;e&&!e.reg[t];)e=T(e);if(e)return e}return null};let Ye=(e,t,r,a,n)=>{let i=Xe(e,a.id);return i?i.reg[a.id]:t?(et(t,a,n),t.reg[a.id]):a};const Ze=e=>e;let et=(e,t,a,n,i)=>{var o;let l=e.reg,s=t.sid,f=null==t||null===(o=t.meta)||void 0===o?void 0:o.serialize;if(l[t.id])return;let d={id:t.id,current:t.current,meta:t.meta};if(s&&s in e.sidValuesMap&&!(s in e.sidIdMap))d.current=(e.fromSerialize&&'ignore'!==f&&(null==f?void 0:f.read)||Ze)(e.sidValuesMap[s]);else if(t.before&&!i){let i=0,o=a||!t.noInit||n;r(t.before,(t=>{switch(t.type){case A:{let r=t.from;if(r||t.fn){r&&et(e,r,a,n);let i=r&&l[r.id].current;o&&(d.current=t.fn?t.fn(i):i)}break}case'field':i||(i=1,d.current=Array.isArray(d.current)?[...d.current]:{...d.current}),et(e,t.from,a,n),o&&(d.current[t.field]=l[l[t.from.id].id].current)}}))}s&&(e.sidIdMap[s]=t.id),l[t.id]=d};const tt=(e,t,r)=>{try{return t(P(r),e.scope,r)}catch(t){console.error(t),e.fail=1}};let rt=(e,r={})=>(pe(e)&&(rt(e.or,r),t(e,((e,t)=>{he(e)||'or'===t||'and'===t||(r[t]=e)})),rt(e.and,r)),r);const at=(e,t)=>{te(e.next,t),te(D(e),t),te(R(e),t)},nt=(e,t,r)=>{let a;e.next.length=0,e.seq.length=0,e.scope=null;let n=R(e);for(;a=n.pop();)at(a,e),(t||r&&'sample'!==L(e,'op')||a.family.type===$)&&nt(a,t,'on'!==L(a,'op')&&r);for(n=D(e);a=n.pop();)at(a,e),r&&a.family.type===$&&nt(a,t,'on'!==L(a,'op')&&r)},ot=e=>e.clear();let lt=(e,{deep:t}={})=>{let r=0;if(e.ownerSet&&e.ownerSet.delete(e),J(e))ot(V(e));else if(X(e)){r=1;let t=e.history;ot(t.events),ot(t.effects),ot(t.stores),ot(t.domains)}nt(E(e),!!t,r)},st=e=>{let t=()=>lt(e);return t.unsubscribe=t,t},ft=(e,t,r,a,n)=>i({node:r,parent:e,child:t,scope:{fn:n},meta:{op:a},family:{owners:[e,t],links:t},regional:1}),dt=(e,t)=>(a(me(t),'.watch argument should be a function'),st(i({scope:{fn:t},node:[Ce({fn:Se})],parent:e,meta:{op:'watch'},family:{owners:e},regional:1}))),ut=(e,t,r=x)=>{T(e)&&T(e).hooks[r](t)},ct=(e,t,r)=>{let a=rt(r),n=e===z,i=ie(),{sid:o=null,named:l=null,domain:f=null,parent:d=f}=a,u=l||a.name||(n?'':i),c=s(u,d),p={op:t.kind=e,name:t.shortName=u,sid:t.sid=de(o),named:l,unitId:t.id=i,serialize:a.serialize,derived:a.derived,config:a};if(t.parent=d,t.compositeName=c,t.defaultConfig=a,t.thru=e=>(ae(0,'thru','js pipe'),e(t)),t.getType=()=>c.fullName,!n){t.subscribe=e=>(ge(e),t.watch(me(e)?e:t=>e.next&&e.next(t))),t[w]=()=>t;let e=fe();e&&(p.nativeTemplate=e)}return p};const pt=(e,t,r,a)=>{let n;pe(r)&&(n=r,r=r.fn);let i=u({name:`${e.shortName} \u2192 *`,derived:1,and:n});return ft(e,i,a,t,r),i},mt=(e,t,r,a,n)=>{let i=_(t),o=ze({store:i,to:F,priority:'read'});r===A&&(o.data.softRead=1);let l=[o,Ne(a)];return d('storeOnMap',i,l,J(e)&&_(e)),ft(e,t,l,r,n)},ht=(e,r,n,i,o)=>{let s=e?e=>[...e]:e=>({...e}),f=e?[]:{},u=s(f),p=Ie(u),m=Ie(1);p.type=e?'list':'shape',p.noInit=1,d('combineBase',p,m);let h=c(u,{name:l(n),derived:1,and:i}),g=_(h);g.noInit=1,W(h,'isCombine',1);let y=Ae(p);y.order={priority:'barrier'};let b=[$e(((e,t,r)=>(r.scope&&!r.scope.reg[p.id]&&(r.c=1),e))),y,ze({store:m,to:'b'}),$e(((e,{key:t},a)=>{if(a.c||e!==a.a[t])return r&&a.b&&(a.a=s(a.a)),a.a[t]=e,1}),1),ze({from:F,target:p}),ze({from:I,store:0,target:m}),ze({from:I,store:1,target:m,priority:O,batch:1}),Ae(p,1),o&&Ne()];return t(n,((e,t)=>{if(!J(e))return a(!U(e)&&!he(e),`combine expects a store in a field ${t}`),void(u[t]=f[t]=e);f[t]=e.defaultState,u[t]=e.getState();let r=ft(e,h,b,'combine',o);r.scope.key=t;let n=_(e);Fe(p,{type:'field',field:t,from:n}),d('combineField',n,r)})),h.defaultShape=n,Fe(g,{type:A,from:p,fn:o}),fe()||(h.defaultState=o?g.current=o(u):f),h};let gt=(e,t,r)=>{try{return[1,e(...r)]}catch(e){return t(e),[0,null]}},yt=e=>{let t=B(e),r={ref:t};return t&&re(t.activeEffects,r),r},bt=(e,t,r,a,n,i)=>l=>{i.ref&&te(i.ref.activeEffects,i),o({target:[a,vt],params:[r?{status:'done',params:e,result:l}:{status:'fail',params:e,error:l},{value:l,fn:r?t.rs:t.rj}],defer:1,page:n.page,scope:i.ref})};const vt=i({node:[Ce({fn:({fn:e,value:t})=>e(t)})],meta:{op:'fx',fx:'sidechain'}}),kt=['source','clock','target'],wt=(e,t)=>e+`: ${t} should be defined`;let St=(e,t,r,n,i,o,l,s,f,m,h,y)=>{let b=!!i;a(!he(r)||!he(t),wt(e,'either source or clock'));let v=0;he(r)?v=1:U(r)||(r=p(r)),he(t)?t=r:(be(t,e,'clock'),Array.isArray(t)&&(t=g(t))),v&&(r=t),s||l||(l=r.shortName);let k='none';(h||n)&&(U(n)?k='unit':(a(me(n),'`filter` should be function or unit'),k='fn')),i?(be(i,e,'target'),ve(e,i)):'none'===k&&m&&J(r)&&J(t)?i=c(o?o(qe(_(r)),qe(_(t))):qe(_(r)),{name:l,sid:y,or:s}):(i=u({name:l,derived:1,or:s}),d('sampleTarget',E(i)));let w=Ie(),S=[];if('unit'===k){let[r,a]=jt(n,i,t,w,e);S=[...xt(a),...xt(r)]}let[x,j]=jt(r,i,t,w,e),z=ft(t,i,[d('sampleSourceLoader'),ze({from:N,target:w}),...xt(j),Ae(x,1,f),...S,Ae(w),'fn'===k&&Ne(((e,t,{a:r})=>n(e,r)),1),o&&Ne(ke),d('sampleSourceUpward',b)],e,o);return ue(r,[z]),Object.assign(z.meta,s,{joint:1}),i};const xt=e=>[Ae(e),$e(((e,t,{a:r})=>r),1)],jt=(e,t,r,a,n)=>{let o=J(e),l=o?_(e):Ie(),s=Ie(o);return o||i({parent:e,node:[ze({from:N,target:l}),ze({from:I,store:1,target:s})],family:{owners:[e,t,r],links:t},meta:{op:n},regional:1}),d('sampleSource',s,l,a),[l,s]},zt=(e,t,r,a)=>{let n=e[t];n&&o({target:n,params:Array.isArray(n)?n.map((()=>r)):r,defer:1,stack:a})},Mt=e=>e;e.allSettled=(e,{scope:t,params:r})=>{if(!U(e))return Promise.reject(new Error('first argument should be unit'));if(!Q(e)&&!K(e)&&!J(e))return Promise.reject(new Error('first argument accepts only effects, events and stores'));let a=m();a.parentFork=We;let{fxCount:n}=t;re(n.scope.defers,a);let i=[e],l=[];return re(l,Q(e)?{params:r,req:{rs(e){a.value={status:'done',value:e}},rj(e){a.value={status:'fail',value:e}}}}:r),re(i,n),re(l,null),o({target:i,params:l,scope:t}),a.req},e.attach=e=>{let t;[e,t]=f(e,1);let{source:r,effect:a,mapParams:n}=e,i=h(e,t);W(i,'attached',1);let l,{runner:d}=E(i).scope,u=$e(((e,t,a)=>{let l,{params:s,req:f,handler:d}=e,u=i.finally,c=yt(a),p=bt(s,f,0,u,a,c),m=a.a,h=Q(d),g=1;if(n?[g,l]=gt(n,p,[s,m]):l=r&&h?m:s,g){if(!h)return e.args=[m,l],1;o({target:d,params:{params:l,req:{rs:bt(s,f,1,u,a,c),rj:p}},page:a.page,defer:1})}}),1,1);if(r){let e;J(r)?(e=r,ue(e,[i])):(e=p(r),ue(i,[e])),l=[Ae(_(e)),u]}else l=[u];d.seq.splice(1,0,...l),i.use(a);let c=T(a);return c&&(Object.assign(H(i),s(i.shortName,c)),i.defaultConfig.parent=c),ut(a,i,j),i},e.clearNode=lt,e.combine=p,e.createApi=(...e)=>{let[[r,a],n]=f(e),i={};return t(a,((e,t)=>{let a=i[t]=u(t,{parent:T(r),config:n});r.on(a,e),ut(r,a)})),i},e.createDomain=function e(a,n){let l=rt({or:n,and:'string'==typeof a?{name:a}:a}),s=i({family:{type:z},regional:1,parent:(null==l?void 0:l.domain)||(null==l?void 0:l.parent)}),f={history:{},graphite:s,hooks:{}};s.meta=ct(z,f,{parent:(null==l?void 0:l.domain)||(null==l?void 0:l.parent),or:l}),t({Event:u,Effect:h,Store:c,Domain:e},((e,t)=>{let a=t.toLowerCase(),n=(e=>u({named:e}))(`on${t}`);f.hooks[a]=n;let i=new Set;f.history[`${a}s`]=i,n.create=e=>(o(n,e),e),re(E(n).seq,$e(((e,t,r)=>(r.scope=null,e)))),n.watch((e=>{ue(f,[e]),i.add(e),e.ownerSet||(e.ownerSet=i),T(e)||(e.parent=f)})),ue(f,[n]),f[`onCreate${t}`]=e=>(r(i,e),n.watch(e)),f[`create${t}`]=f[a]=(t,r)=>{let a=rt({and:r,or:t});return null!=a&&a.domain?e(t,r):n(e(t,{parent:f,or:a}))}}));let d=T(f);return d&&t(f.hooks,((e,t)=>ft(e,d.hooks[t]))),null!=l&&l.domain&&l.domain.hooks.domain(f),f},e.createEffect=h,e.createEvent=u,e.createNode=i,e.createStore=c,e.createStoreObject=(...e)=>(ae(0,'createStoreObject','combine'),p(...e)),e.createWatch=({unit:e,fn:t,scope:r})=>{let a=[Oe.run({fn:e=>t(e)})];if(r){let t=i({node:a}),n=e.graphite.id,o=r.additionalLinks,l=o[n]||[];return o[n]=l,l.push(t),k((()=>{let e=l.indexOf(t);-1!==e&&l.splice(e,1),lt(t)}))}{let t=i({node:a,parent:[e],family:{owners:e}});return k((()=>{lt(t)}))}},e.fork=(e,t)=>{let n,o=e;X(e)&&(n=e,o=t);let l=(e=>{let t=i({scope:{defers:[],inFlight:0,fxID:0},node:[$e(((e,t,r)=>{T(r)?'dec'===L(T(r).node,'needFxCounter')?t.inFlight-=1:(t.inFlight+=1,t.fxID+=1):t.fxID+=1})),Me({priority:C,batch:1}),$e(((e,t)=>{let{defers:a,fxID:n}=t;t.inFlight>0||0===a.length||Promise.resolve().then((()=>{t.fxID===n&&r(a.splice(0,a.length),(e=>{Ke(e.parentFork),e.rs(e.value)}))}))}),0,1)]}),a=i({node:[$e(((e,t,r)=>{let a=T(r);if(a){let t=a.node;if(!L(t,'isCombine')||T(a)&&'combine'!==L(T(a).node,'op')){let a=B(r),n=t.scope.state.id,i=L(t,'sid');a.sidIdMap[i]=n,a.sidValuesMap[i]=e;let o=L(t,'serialize');o&&'ignore'!==o&&(a.sidSerializeMap[i]=o.write)}}}))]}),n=i({node:[$e(((e,t,r)=>{let a=B(r);if(a){let e=T(r);e&&(!L(e.node,'isCombine')||T(e)&&'combine'!==L(T(e).node,'op'))&&(a.warnSerialize=1)}}))]}),o={cloneOf:e,reg:{},sidValuesMap:{},sidIdMap:{},sidSerializeMap:{},getState(e){if('current'in e)return Ye(Je,o,null,e).current;let t=E(e);return Ye(Je,o,t,t.scope.state,1).current},kind:M,graphite:i({family:{type:z,links:[t,a,n]},meta:{unit:'fork'},scope:{forkInFlightCounter:t}}),additionalLinks:{},handlers:{},fxCount:t,storeChange:a,warnSerializeNode:n,activeEffects:[]};return o})(n);if(o){let e=o.scope;if(e){let t=e.activeEffects;e.activeEffects=[],l.activeEffects=t,r(t,(e=>e.ref=l))}if(o.values){let e=v(o.values,(e=>a(J(e),'Values map can contain only stores as keys')));Object.assign(l.sidValuesMap,e),l.fromSerialize=!(Array.isArray(o.values)||o.values instanceof Map)}o.handlers&&(l.handlers=v(o.handlers,(e=>a(Q(e),"Handlers map can contain only effects as keys"))))}return l},e.forward=e=>{let t='forward',[{from:r,to:a},n]=f(e,1);return be(r,t,'"from"'),be(a,t,'"to"'),ve(t,a,'to'),st(i({parent:r,child:a,meta:{op:t,config:n},family:{},regional:1}))},e.fromObservable=e=>{ge(e);let t=w in e?e[w]():e;a(t.subscribe,'expect observable to have .subscribe');let r=u(),n=st(r);return t.subscribe({next:r,error:n,complete:n}),r},e.guard=(...e)=>{let[[t,r],a]=f(e);return r||(r=t,t=r.source),y(r,'guard'),St('guard',r.clock,t,r.filter,r.target,null,r.name,a,!r.greedy,0,1)},e.hydrate=(e,{values:t})=>{a(pe(t),'values property should be an object');let r,n,i,l=v(t),s=Object.getOwnPropertyNames(l),f=[],d=[];Y(e)?(r=e,i=1,a(r.cloneOf,'scope should be created from domain'),n=E(r.cloneOf)):X(e)?n=E(e):a(0,'first argument of hydrate should be domain or scope'),b(n,((e,t)=>{if(ee(s,t)){re(f,e);let r=L(e,'serialize');r&&'ignore'!==r&&(l[t]=r.read(l[t])),re(d,l[t])}})),o({target:f,params:d,scope:r}),i&&Object.assign(r.sidValuesMap,l)},e.is=Z,e.launch=o,e.merge=g,e.restore=(e,r,a)=>{if(J(e))return ae(0,'restore($store)'),e;if(K(e)||Q(e)){let t=T(e),n=c(r,{parent:t,name:e.shortName,and:a});return ft(Q(e)?e.doneData:e,n),t&&t.hooks.store(n),n}let n=Array.isArray(e)?[]:{};return t(e,((e,t)=>n[t]=J(e)?e:c(e,{name:t}))),n},e.sample=(...e)=>{let t,r,a,n,[[i,o,l],s]=f(e),d=1;return he(o)&&pe(i)&&y(i,q)&&(o=i.clock,l=i.fn,d=!i.greedy,n=i.filter,t=i.target,r=i.name,a=i.sid,i=i.source),St(q,o,i,n,t,l,r,s,d,1,0,a)},e.scopeBind=(e,{scope:t,safe:r}={})=>{a(t||We||r,'scopeBind cannot be called outside of forked .watch');let n=t||We;return Q(e)?t=>{let r=m();return o({target:e,params:{params:t,req:r},scope:n}),r.req}:t=>(o({target:e,params:t,scope:n}),t)},e.serialize=(e,r={})=>{e.warnSerialize&&console.error('There is a store without sid in this scope, its value is omitted');let n=r.ignore?r.ignore.map((({sid:e})=>e)):[],i={};return t(e.sidValuesMap,((t,r)=>{if(ee(n,r))return;let a=e.sidIdMap[r];i[r]=(e.sidSerializeMap[r]||Mt)(a&&a in e.reg?e.reg[a].current:t)})),'onlyChanges'in r&&!r.onlyChanges&&(a(e.cloneOf,'scope should be created from domain'),b(E(e.cloneOf),((t,r)=>{r in i||ee(n,r)||L(t,'isCombine')||'ignore'===L(t,'serialize')||(i[r]=e.getState(t))}))),i},e.setStoreName=(e,t)=>{e.shortName=t,Object.assign(H(e),s(t,T(e)))},e.split=(...e)=>{let r,n,o='split',[[l,s],c]=f(e),p=!s;p&&(r=l.cases,s=l.match,n=l.clock,l=l.source);let m=J(s),h=!U(s)&&me(s),g=!m&&!h&&pe(s);r||(r={}),p?t(r,((e,t)=>ve(o,e,`cases.${t}`))):(a(g,'match should be an object'),t(s,((e,t)=>r[t]=u({derived:1,and:c}))),r.__=u({derived:1,and:c}));let y,b=new Set([].concat(l,n||[],Object.values(r))),v=Object.keys(m||h?r:s);if(m||h)m&&b.add(s),y=[m&&Ae(_(s),0,1),Me({safe:m,filter:1,pure:!m,fn(e,t,r){let a=String(m?r.a:s(e));zt(t,ee(v,a)?a:'__',e,r)}})];else if(g){let e=Ie({});e.type='shape';let r,a=[];t(s,((t,n)=>{if(U(t)){r=1,re(a,n),b.add(t);let i=ft(t,[],[Ae(e),$e(((e,t,{a:r})=>r[n]=e))]);if(J(t)){e.current[n]=t.getState();let r=_(t);Fe(e,{from:r,field:n,type:'field'}),d('splitMatchStore',r,i)}}})),r&&d('splitBase',e),y=[r&&Ae(e,0,1),Ne(((e,t,r)=>{for(let n=0;n<v.length;n++){let i=v[n];if(ee(a,i)?r.a[i]:s[i](e))return void zt(t,i,e,r)}zt(t,'__',e,r)}),1)]}else a(0,'expect match to be unit, function or object');let k=i({meta:{op:o},parent:n?[]:l,scope:r,node:y,family:{owners:Array.from(b)},regional:1});if(n&&St(o,n,l,null,k,null,o,c,0,0,0),!p)return r},e.step=Oe,e.version="22.4.0",e.withFactory=({sid:e,name:t,loc:r,method:a,fn:o})=>n(i({meta:{sidRoot:de(e),name:t,loc:r,method:a}}),o),e.withRegion=n,Object.defineProperty(e,'__esModule',{value:1})}));
//# sourceMappingURL=effector.umd.js.map
