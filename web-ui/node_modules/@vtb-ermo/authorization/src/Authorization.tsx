import React, { createContext, useCallback, useEffect, useLayoutEffect, useMemo, useState } from 'react';
import { isIntersection, isValidUser, unique } from './utils';
import { sign } from 'jsonwebtoken';
import { userStatusDependencies, userUpdateIntervalSec } from './constants';

import type { IAuthProvider, IUser, PermissionCode, StatusAvailability, UserStatusCode } from './types';

export const _devAuthHeaders: HeadersInit = {};

export const AuthContext = createContext<IAuthProvider>({} as any);

export const AuthProvider: React.FC<{ endpoint?: string, devMode?: boolean }> = props => {

    const { endpoint = '', devMode } = props;

    const [isAuthorized, setAuthorized] = useState<IAuthProvider['isAuthorized']>(false);
    const [isInit, setIsInit] = useState<IAuthProvider['isInit']>(false);
    const [user, setUser] = useState<IUser>({} as any);
    const [userId, setUserId] = useState<IUser['id'] | null>(localStorage.getItem('userId'));
    const [statuses, setStatuses] = useState<Array<UserStatusCode>>([]);

    const permissionCodes = useMemo(() => {
        const codes: Array<PermissionCode> = [];
        user?.roles?.forEach(r => r?.permissions?.forEach(p => codes.push(p.code)));
        return unique(codes) as Array<PermissionCode>;
    }, [user?.roles]);

    const roleCodes = useMemo(() => {
        return user?.roles?.map(r => r.code) || [];
    }, [user?.roles]);

    const availableStatuses: Array<StatusAvailability> = useMemo(() => {
        return statuses.map(status => ({
            code: status,
            available: !!userStatusDependencies[user.status]?.includes(status),
        }));
    }, [statuses, user.status]);

    const checkPermission = useCallback<IAuthProvider['checkPermission']>(requiredPermissions => {
        return isIntersection(permissionCodes, requiredPermissions);
    }, [permissionCodes]);

    const updateUserStatus = useCallback<IAuthProvider['updateUserStatus']>((userStatus: UserStatusCode) => {
        if (!user || !userStatus) return Promise.reject(new Error('User unknown'));
        return fetch(`${endpoint}/users/${user.id}/status`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ status: userStatus }),
        }).then(response => {
            if (response.ok) setUser(prevState => prevState && { ...prevState, status: userStatus });
            else return Promise.reject(new Error('Bad request'));
        });
    }, [user]);

    const _changeUser = useCallback((userId: IUser['id']) => {
        localStorage.setItem('userId', userId.toString());
        setUserId(userId);
    }, []);

    useLayoutEffect(() => {
        if (userId && devMode) {
            const token = sign({ sub: userId }, 'your-256-bit-secret', { algorithm: 'HS256' });
            Object.assign(_devAuthHeaders, { Authorization: `Bearer ${token}` })
        } else {
            delete _devAuthHeaders['Authorization'];
        }
    }, [userId]);

    useEffect(() => {
        const requestUser = async (): Promise<IUser> => {
            try {
                const response = await fetch(`${endpoint}/users/current`, { headers: _devAuthHeaders });
                return response.ok
                    ? await response.json() as IUser
                    : Promise.reject(`${response.status} (${response.statusText})`);
            } catch (err) {
                return Promise.reject(err);
            }
        };
        const requestStatuses = async (): Promise<Array<UserStatusCode>> => {
            try {
                const response = await fetch(`${endpoint}/users/statuses`, { headers: _devAuthHeaders });
                return response.ok
                    ? await response.json() as Array<UserStatusCode>
                    : Promise.reject(`${response.status} (${response.statusText})`);
            } catch (err) {
                return Promise.reject(err);
            }
        }
        Promise.all([requestUser(), requestStatuses()])
            .then(response => {
                const [user, statuses] = response;
                if (user && isValidUser(user) && statuses.length) {
                    setUser(user);
                    setStatuses(statuses);
                    setAuthorized(true);
                }
                else {
                    setAuthorized(false);
                }
            })
            .catch(err => console.error(err))
            .finally(() => setIsInit(true));
        const timerId = setInterval(() => {
            requestUser().then((response) => {
                if (user && isValidUser(user)) {
                    setUser(response);
                }
            })
        }, userUpdateIntervalSec * 1000);
        return () => clearInterval(timerId);
    }, [userId]);

    return (
        <AuthContext.Provider value={{
            checkPermission,
            isAuthorized,
            isInit,
            availableStatuses,
            permissionCodes,
            roleCodes,
            updateUserStatus,
            user,
            _changeUser,
            _devAuthHeaders,
        }}>
            {props.children}
        </AuthContext.Provider>
    );

};