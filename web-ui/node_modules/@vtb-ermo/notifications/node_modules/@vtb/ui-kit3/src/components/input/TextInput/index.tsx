import type { InputStatus, InputTypes } from '~/components/input/inputTypes';
import type { ForwardedRef } from 'react';
import * as React from 'react';
import { InputHTMLAttributes, useLayoutEffect, useRef } from 'react';
import styled, { css } from 'styled-components';
import { refSetter } from '~/components/common/utils/refSetter';
import { changeInputData, InputData } from '~/components/common/dom/changeInputData';
import { typography } from '~/components/Typography';
import { StatusIcon } from '../StatusIcon';
import { ReactComponent as CloseOutlineSvg } from '@openvtb/admiral-icons/build/service/CloseOutline.svg';
import { ReactComponent as EyeCloseOutlineSvg } from '@openvtb/admiral-icons/build/service/EyeCloseOutline.svg';
import { ReactComponent as EyeOutlineSvg } from '@openvtb/admiral-icons/build/service/EyeOutline.svg';

export interface ExtraProps {
  /** Делает высоту компонента больше или меньше обычной */
  dimension?: InputTypes;

  /** Количество иконок отображаемых справа */
  iconCount?: number;
}

const EyeCloseIcon = styled(EyeCloseOutlineSvg)`
  > * {
    fill: ${(props) => props.theme.color.basic.tertiary};
  }

  &:hover {
    cursor: pointer;
  }

  &:hover > * {
    fill: ${(props) => props.theme.color.basic.hover};
  }
`;

const EyeIcon = styled(EyeOutlineSvg)`
  > * {
    fill: ${(props) => props.theme.color.basic.tertiary};
  }

  &:hover {
    cursor: pointer;
  }

  &:hover > * {
    fill: ${(props) => props.theme.color.basic.hover};
  }
`;

const ClearIcon = styled(CloseOutlineSvg)`
  > * {
    fill: ${(props) => props.theme.color.basic.tertiary};
  }

  &:hover {
    cursor: pointer;
  }

  &:hover > * {
    fill: ${(props) => props.theme.color.basic.hover};
  }
`;

const heights = css<{ dimension?: InputTypes }>`
  height: ${({ dimension }) => {
    switch (dimension) {
      case 'xl':
        return '56px';
      case 's':
        return '32px';
      default:
        return '40px';
    }
  }};
`;

const iconSizeValue = (props: { dimension?: InputTypes }) => {
  switch (props.dimension) {
    case 'xl':
      return 24;
    case 's':
      return 20;
    default:
      return 24;
  }
};
const horizontalPaddingValue = (props: { dimension?: InputTypes }) => {
  switch (props.dimension) {
    case 'xl':
      return 16;
    case 's':
      return 12;
    default:
      return 16;
  }
};

const extraPadding = css<ExtraProps>`
  padding-right: ${(props) =>
    horizontalPaddingValue(props) +
    (iconSizeValue(props) + 8) * (props.iconCount ?? 0) -
    8 * (props.iconCount ? 1 : 0)}px;
`;

const disabledColors = css`
  background-color: ${(props) => props.theme.color.background.tertiary};
  border-color: ${(props) => props.theme.color.background.tertiary};
`;

const colorsBorderAndBackground = css<{ disabled?: boolean }>`
  background-color: ${(props) => props.theme.color.background.primary};
  border: 1px solid ${(props) => props.theme.color.basic.tertiary};
  border-radius: 4px;

  ${({ disabled }) => (disabled ? disabledColors : '')}
  &[data-focus-within] {
    border-color: ${(props) => props.theme.color.basic.press};
    outline: -webkit-focus-ring-color auto 1px;
  }

  &:hover {
    border-color: ${(props) => props.theme.color.basic.hover};
  }
`;

const ieFixes = css`
  ::-ms-clear,
  ::-ms-reveal {
    display: none;
  }
`;

const Input = styled.input<ExtraProps>`
  outline: none;
  appearance: none;

  box-sizing: border-box;
  flex: 1 1 auto;
  min-width: 10px;
  border: none;
  background: transparent;
  text-overflow: ellipsis;
  padding: 0 ${horizontalPaddingValue}px;

  color: ${(props) => props.theme.color.text.primary};

  ${(props) => (props.dimension === 's' ? typography['Additional/S'] : typography['Additional/L'])}
  &::placeholder {
    color: ${(props) => props.theme.color.text.secondary};
  }

  &:disabled::placeholder {
    color: ${(props) => props.theme.color.text.tertiary};
  }

  [data-read-only] & {
    user-select: none;
    pointer-events: none;
    ${disabledColors}
  }

  ${colorsBorderAndBackground}
  ${extraPadding}
  ${ieFixes}
  [data-status='error'] &,
  &:invalid {
    border-color: ${(props) => props.theme.color.status.danger};
  }

  [data-status='success'] & {
    border-color: ${(props) => props.theme.color.status.success};
  }
`;

const Container = styled.div<{ disabled?: boolean; dimension?: InputTypes }>`
  position: relative;
  display: flex;
  align-items: stretch;
  border: none;

  ${heights}
  &[data-read-only] {
    user-select: none;
    pointer-events: none;
  }
`;

const IconPanel = styled.div<{ disabled?: boolean; dimension?: InputTypes }>`
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;

  display: flex;
  align-items: center;

  padding-right: ${horizontalPaddingValue}px;

  & > * {
    display: block;
    width: ${iconSizeValue}px;
  }

  & > *:not(:first-child) {
    margin-left: 8px;
  }
`;

function defaultHandleInput(newInputData: InputData): InputData {
  return newInputData;
}

const stopEvent = (e: React.MouseEvent) => e.preventDefault();

export type CustomInputHandler = (newInputData: InputData) => InputData;

export interface TextInputProps extends InputHTMLAttributes<HTMLInputElement> {
  /** Делает высоту компонента больше или меньше обычной */
  dimension?: InputTypes;

  /** Иконки для отображения в правом углу поля */
  icons?: React.ReactNode;

  /** Отображать иконку статуса */
  displayStatusIcon?: boolean;

  /** Отображать иконку очистки поля */
  displayClearIcon?: boolean;

  /** Статус поля */
  status?: InputStatus;

  /** Ref контейнера компонента */
  containerRef?: ForwardedRef<HTMLDivElement>;

  /**
   * Дает возможность изменить значение поля ввода и позицию курсора до момента отображения при следующем цикле рендеринга.
   * Используется для создания масок ввода
   */
  handleInput?: CustomInputHandler;

  /**  Наличие этого атрибута отключает возможность выделения и копирования значения поля */
  disableCopying?: boolean;
}

export const TextInput = React.forwardRef<HTMLInputElement, TextInputProps>(
  (
    {
      type,
      value,
      displayStatusIcon,
      displayClearIcon,
      status,
      handleInput = defaultHandleInput,
      containerRef,
      icons,
      children,
      className,
      ...props
    },
    ref,
  ) => {
    const inputRef = useRef<HTMLInputElement>(null);

    const iconArray = React.Children.toArray(icons);

    const [isPasswordVisible, setPasswordVisible] = React.useState(false);
    if (type === 'password') {
      const Icon = isPasswordVisible ? EyeIcon : EyeCloseIcon;
      iconArray.push(
        <Icon
          key="eye-icon"
          aria-hidden
          onClick={() => {
            setPasswordVisible(!isPasswordVisible);
          }}
        />,
      );
    }

    if (displayStatusIcon) {
      iconArray.push(<StatusIcon key="status-icon" status={status} aria-hidden />);
    }

    if (displayClearIcon) {
      iconArray.unshift(
        <ClearIcon
          key="clear-icon"
          onClick={() => {
            if (inputRef.current) {
              changeInputData(inputRef.current, { value: '' });
            }
          }}
          aria-hidden
        />,
      );
    }

    const iconCount = iconArray.length;

    const inputData = value ? handleInput({ value: String(value) }) : {};

    useLayoutEffect(() => {
      function oninput(this: HTMLInputElement) {
        const { value, selectionStart, selectionEnd } = this;
        const currentInputData = { value, selectionStart, selectionEnd };

        const inputData = handleInput(currentInputData);
        changeInputData(this, inputData);
      }

      if (inputRef.current) {
        const node = inputRef.current;
        node.addEventListener('input', oninput);

        const { value, selectionStart, selectionEnd } = node;
        const currentInputData = { value, selectionStart, selectionEnd };
        const inputData = handleInput(currentInputData);
        changeInputData(node, inputData);

        return () => {
          node.removeEventListener('input', oninput);
        };
      }
    }, [inputRef.current, handleInput]);
    return (
      <Container
        className={className}
        disabled={props.disabled}
        dimension={props.dimension}
        ref={containerRef}
        data-read-only={props.readOnly}
        {...(props.disableCopying && {
          onMouseDown: stopEvent,
        })}
      >
        <Input
          ref={refSetter(ref, inputRef)}
          {...props}
          iconCount={iconCount}
          value={inputData.value}
          type={type === 'password' && isPasswordVisible ? 'text' : type}
        />
        {iconCount > 0 && (
          <IconPanel disabled={props.disabled} dimension={props.dimension}>
            {iconArray}
          </IconPanel>
        )}
        {children}
      </Container>
    );
  },
);

TextInput.defaultProps = {
  dimension: 'm',
};
TextInput.displayName = 'TextInput';
