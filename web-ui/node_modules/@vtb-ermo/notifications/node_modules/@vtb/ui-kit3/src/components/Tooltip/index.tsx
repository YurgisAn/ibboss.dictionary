import type { FC, ReactNode } from 'react';
import React, { HTMLAttributes, useEffect, useRef, useState } from 'react';
import ReactDOM from 'react-dom';

import type { RefCallback, RefObject } from '../common/utils/handleRef';
import { handleRef } from '../common/utils/handleRef';
import { getScrollableParents } from '../common/utils/getScrollableParents';

import { AnchorWrapper } from './AnchorWrapper';
import { TooltipWrapper } from './TooltipWrapper';
import type { CalculationResult } from './utils';
import { calculateDirection } from './utils';

export interface ITooltipProps extends HTMLAttributes<HTMLDivElement> {
  /** Функция, которая возвращает реакт-компонент с контентом тултипа. Если этому компоненту нужны props, используйте замыкание */
  renderContent: () => ReactNode;
  /** Контейнер, в котором будет отрисован тултип через React.createPortal. По умолчанию тултип отрисовывается в document.body */
  container?: Element | null;
  /** Отобразить тултип с задержкой в 1.5 секунды */
  withDelay?: boolean;
  /** Ссылка на тултип */
  tooltipRef?: RefCallback<HTMLDivElement> | RefObject<HTMLDivElement> | null;
}

const TOOLTIP_DELAY = 1500;

export const Tooltip: FC<ITooltipProps> = ({
  renderContent,
  container,
  withDelay,
  tooltipRef,
  children,
  className,
  ...props
}) => {
  const anchorElementRef = useRef<HTMLDivElement | null>(null);
  const tooltipElementRef = useRef<HTMLDivElement | null>(null);
  const portal: Element = container || document.body;
  let scrollableParents: Array<Element> | undefined = undefined;
  let showTooltipTimer: any;

  const [visible, setVisible] = useState<boolean>(false);

  const hideTooltip = () => setVisible(false);

  const manageTooltip = () => {
    if (anchorElementRef.current && tooltipElementRef.current) {
      const directionCalculationResult: CalculationResult = calculateDirection(
        anchorElementRef.current,
        tooltipElementRef.current,
      );
      const anchorElementRect = anchorElementRef.current.getBoundingClientRect();
      const tooltipElementRect = tooltipElementRef.current.getBoundingClientRect();
      const calculatedStyles = directionCalculationResult.getStyles(anchorElementRect, tooltipElementRect);
      tooltipElementRef.current.style.transform = calculatedStyles;
    }
  };

  const attachRef = (node: HTMLDivElement) => handleRef(node, tooltipRef, tooltipElementRef);

  useEffect(() => {
    window.addEventListener('resize', hideTooltip);
    window.addEventListener('scroll', hideTooltip);

    /**  если у anchorElement есть родительский элемент, который имеет собственный скролл,
     * необходимо повесить на этого родителя обработчик скролла */
    if (!scrollableParents && anchorElementRef.current) {
      scrollableParents = getScrollableParents(anchorElementRef.current);
      scrollableParents?.forEach((el) => el.addEventListener('scroll', hideTooltip));
    }
    return () => {
      window.removeEventListener('resize', hideTooltip);
      window.removeEventListener('scroll', hideTooltip);
      scrollableParents?.forEach((el) => el.removeEventListener('scroll', hideTooltip));
    };
  });

  useEffect(() => {
    manageTooltip();
  }, [renderContent(), anchorElementRef]);

  const handleMouseEnter = () => {
    showTooltipTimer = window.setTimeout(
      () => {
        setVisible(true);
        manageTooltip();
      },
      withDelay ? TOOLTIP_DELAY : 0,
    );
  };

  const handleMouseLeave = () => {
    clearTimeout(showTooltipTimer);
    hideTooltip();
  };

  return (
    <AnchorWrapper
      onMouseEnter={handleMouseEnter}
      onMouseLeave={handleMouseLeave}
      onFocus={handleMouseEnter}
      onBlur={handleMouseLeave}
      ref={anchorElementRef}
      className={className}
    >
      {children}
      {visible &&
        ReactDOM.createPortal(
          <TooltipWrapper role="tooltip" ref={attachRef} {...props}>
            {renderContent()}
          </TooltipWrapper>,
          portal,
        )}
    </AnchorWrapper>
  );
};
