import React, { forwardRef, HTMLAttributes, MutableRefObject, ReactNode, useLayoutEffect, useRef } from 'react';
import styled, { css } from 'styled-components';
import { keyboardKey } from '~/components/common/keyboardKey';
import { refSetter } from '~/components/common/utils/refSetter';
import { moveFocus, nextItem, previousItem } from './utils';

export type DropDownDimensions = 'l' | 'm';

export const heights = css<{ dimension: DropDownDimensions }>`
  max-height: ${({ dimension }) => {
    switch (dimension) {
      case 'l':
        return `${48 * 6}px`;
      case 'm':
        return `${40 * 6}px`;
      default:
        return `${48 * 6}px`;
    }
  }};
`;

const MenuList = styled.ul<{ dimension: DropDownDimensions }>`
  border-radius: 4px;
  ${({ theme }) => theme.shadow.NonClickable};
  background: ${({ theme }) => theme.color.background.primary};
  ${heights}
  overflow-x: hidden;
  overflow-y: auto;
  cursor: pointer;
  position: absolute;
  padding: 8px 0;
  width: 300px;
  outline: none;
  margin: 0;
`;

export interface DropDownMenuProps extends HTMLAttributes<HTMLUListElement> {
  dimension?: DropDownDimensions;
  children: ReactNode;
  onMenuReachTop: () => void;
  onMenuReachBottom: () => void;
  menuFocus: 'firstOption' | 'lastOption' | 'activeOption';
  setMenuFocus: React.Dispatch<React.SetStateAction<'firstOption' | 'lastOption' | 'activeOption'>>;
}

export const DropDownMenu = forwardRef<HTMLUListElement, DropDownMenuProps>(
  ({ children, dimension = 'l', onMenuReachBottom, onMenuReachTop, menuFocus, setMenuFocus, ...props }, ref) => {
    const menuRef: MutableRefObject<any> = useRef();

    const handleKeyDown = (e: any) => {
      const focusedOption = (menuRef.current?.ownerDocument || document).activeElement;
      const code = keyboardKey.getCode(e);
      if (code === keyboardKey.ArrowRight) {
        moveFocus(menuRef.current, focusedOption, nextItem, true, onMenuReachTop, onMenuReachBottom);
        e.preventDefault();
      } else if (code === keyboardKey.ArrowLeft) {
        moveFocus(menuRef.current, focusedOption, previousItem, true, onMenuReachTop, onMenuReachBottom);
        e.preventDefault();
      } else if (e.keyCode === 32) {
        e.preventDefault();
      } else if (code === keyboardKey.Home) {
        e.preventDefault();
        moveFocus(menuRef.current, null, nextItem);
      } else if (code === keyboardKey.End) {
        e.preventDefault();
        moveFocus(menuRef.current, null, previousItem);
      }
      props?.onKeyDown?.(e);
    };

    const getMenuFirstOption = () => {
      let option = menuRef.current?.firstElementChild;
      while (option.hasAttribute('disabled')) {
        option = option.nextElementSibling;
      }
      return option;
    };

    const getMenuLastOption = () => {
      let option = menuRef.current?.lastElementChild;
      while (option.hasAttribute('disabled')) {
        option = option.previousElementSibling;
      }
      return option;
    };

    useLayoutEffect(() => {
      if (menuRef.current !== document.activeElement) {
        menuRef.current?.focus();
      }
      const activeOption = menuRef.current?.querySelector('[aria-selected="true"]');
      let selectedItem;
      if (menuFocus === 'firstOption') selectedItem = getMenuFirstOption();
      if (menuFocus === 'lastOption') selectedItem = getMenuLastOption();
      if (menuFocus === 'activeOption') selectedItem = activeOption || getMenuFirstOption();
      (selectedItem as HTMLElement)?.focus();
    }, [menuRef, nextItem, moveFocus]);

    return (
      <MenuList ref={refSetter(ref, menuRef)} dimension={dimension} {...props} onKeyDown={handleKeyDown}>
        {children}
      </MenuList>
    );
  },
);
