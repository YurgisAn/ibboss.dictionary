import type { FC, KeyboardEvent, MouseEvent, ReactNode, RefObject } from 'react';
import React, { createRef, HTMLAttributes, useLayoutEffect, useRef, useState } from 'react';
import { keyboardKey } from '~/components/common/keyboardKey';
import observeRect from '~/components/common/observeRect';

import { Badge } from '../Badge';
import { TabOverflowMenu } from '../TabOverflowMenu';

import measureTab from './measureTab';
import { Tab, TabContent, TabContentWrapper, TabsWrapper, Underline, Wrapper } from './style';
import type { Dimension } from './constants';
import { OVERFLOW_MARGIN_LEFT, OVERFLOW_SIZE_L, OVERFLOW_SIZE_M } from './constants';

export interface TabProps extends HTMLAttributes<HTMLButtonElement> {
  /** Контент вкладки */
  content: ReactNode;
  /** Id вкладки */
  id: string;
  /** Иконка, располагается слева от content */
  icon?: ReactNode;
  /** Число, которое будет отображено в компоненте Badge справа от content */
  badge?: number;
  /** Отключение вкладки */
  disabled?: boolean;
}

type TabWithRefProps = TabProps & { ref: RefObject<HTMLButtonElement>; width?: number };

export interface TabMenuProps extends Omit<HTMLAttributes<HTMLDivElement>, 'onChange'> {
  /** Список вкладок */
  tabs: Array<TabProps>;
  /** Id активной вкладки */
  activeTab: string;
  /** Колбек на изменение активной вкладки */
  onChange: (id: string) => void;
  /** Размер компонента */
  dimension?: Dimension;
  /** Отображение серой полосы снизу */
  underline?: boolean;
  /** Мобильная версия компонента */
  mobile?: boolean;
}

export const TabMenu: FC<TabMenuProps> = ({
  tabs,
  dimension = 'l',
  underline = false,
  mobile = false,
  activeTab,
  onChange,
  ...props
}) => {
  // add refs to tabs
  const tabsWithRef: Array<TabWithRefProps> = React.useMemo(() => {
    return tabs.map((tab) => ({ ...tab, ref: createRef<HTMLButtonElement>() }));
  }, [tabs]);

  const tabsWrapperRef = useRef<HTMLDivElement | null>(null);
  const tablistRef = useRef<HTMLDivElement | null>(null);
  const overflowBtnRef = useRef<HTMLButtonElement | null>(null);
  const underlineRef = useRef<HTMLDivElement | null>(null);
  const [visibleTabsAmount, setVisibleTabsAmount] = useState(tabsWithRef.length);
  const [underlineRect, setUnderlineRect] = useState<{
    width: number;
    left: number;
  }>({
    width: 0,
    left: 0,
  });
  const [menuFocus, setMenuFocus] = useState<'firstOption' | 'lastOption' | 'activeOption'>('activeOption');
  const { left, width: underlineWidth } = underlineRect;

  const visibleTabs = mobile ? tabsWithRef : tabsWithRef.slice(0, visibleTabsAmount);
  const hiddenTabs = mobile ? [] : tabsWithRef.slice(visibleTabsAmount);

  const getNextFocus = (target: HTMLElement) => {
    let sibling: Element | null | undefined =
      target.nextElementSibling || overflowBtnRef.current || tabsWrapperRef.current?.firstElementChild;
    while (sibling?.hasAttribute('disabled')) {
      sibling = sibling.nextElementSibling || overflowBtnRef.current || tabsWrapperRef.current?.firstElementChild;
    }
    return sibling;
  };
  const getPreviousFocus = (target: HTMLElement) => {
    let sibling: Element | null | undefined =
      target.previousElementSibling || overflowBtnRef.current || tabsWrapperRef.current?.lastElementChild;
    while (sibling?.hasAttribute('disabled')) {
      sibling = sibling.previousElementSibling || overflowBtnRef.current || tabsWrapperRef.current?.lastElementChild;
    }
    return sibling;
  };

  const focusFirstTab = () => {
    let tab = tabsWrapperRef.current?.firstElementChild;
    while (tab?.hasAttribute('disabled')) {
      tab = tab.nextElementSibling;
    }
    tab ? (tab as HTMLElement).focus() : (overflowBtnRef.current as HTMLElement).focus();
  };

  const focusLastTab = () => {
    let tab = tabsWrapperRef.current?.lastElementChild;
    while (tab?.hasAttribute('disabled')) {
      tab = tab.previousElementSibling;
    }
    tab ? (tab as HTMLElement).focus() : (overflowBtnRef.current as HTMLElement).focus();
  };

  const setUnderline = () => {
    const activeTabRef = tabsWithRef.filter((tab) => tab.id === activeTab)?.[0]?.ref.current;
    if (activeTabRef && (activeTabRef.offsetLeft !== left || activeTabRef.clientWidth !== underlineWidth)) {
      setUnderlineRect({
        left: activeTabRef.offsetLeft,
        width: activeTabRef.clientWidth,
      });
    }
    if (!activeTabRef || hiddenTabs.filter((tab) => tab.id === activeTab).length) {
      setUnderlineRect({
        left: 0,
        width: 0,
      });
    }
  };

  // measure tabs sizes
  useLayoutEffect(() => {
    tabsWithRef.forEach((tab: any) => {
      measureTab(tab, dimension, (width: number) => {
        tab.width = width;
      });
    });
  }, [tabsWithRef, dimension]);

  useLayoutEffect(() => setUnderline(), [tabs, left, underlineWidth, tabsWithRef, activeTab, visibleTabsAmount]);

  // recalculation on Tabmenu resize
  useLayoutEffect(() => {
    if (tablistRef.current) {
      const observer = observeRect(tablistRef.current, (rect) => {
        const tablistWidth = rect?.width || 0;
        let contentWidth =
          dimension === 'l' ? OVERFLOW_SIZE_L + OVERFLOW_MARGIN_LEFT : OVERFLOW_SIZE_M + OVERFLOW_MARGIN_LEFT;
        let visibleTabsCounter = 0;
        tabsWithRef.forEach((item: TabWithRefProps) => {
          contentWidth += item.width || 0;
          if (contentWidth <= tablistWidth) {
            visibleTabsCounter++;
          }
        });
        setVisibleTabsAmount(visibleTabsCounter);
      });
      observer.observe();
      return () => {
        observer.unobserve();
      };
    }
  }, [tablistRef.current]);

  // recalculation on Tabs Wrapper resize. For example, it happens after fonts loading
  useLayoutEffect(() => {
    if (tabsWrapperRef.current) {
      const observer = observeRect(tabsWrapperRef.current, () => setUnderline());
      observer.observe();
      return () => {
        observer.unobserve();
      };
    }
  }, [tabsWrapperRef.current]);

  const handleTabClick = (event: MouseEvent<HTMLButtonElement>) => {
    mobile && event.currentTarget.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
    onChange(event.currentTarget.id);
  };

  const handleTabKeyUp = (event: KeyboardEvent<HTMLButtonElement>) => {
    const code = keyboardKey.getCode(event);
    if (code === keyboardKey.Enter || code === keyboardKey[' ']) {
      onChange(event.currentTarget.id);
    }
  };

  const handleTabsWrapperKeyDown = (event: KeyboardEvent<HTMLDivElement>) => {
    const { target } = event;
    let newFocusTarget;

    const code = keyboardKey.getCode(event);
    switch (code) {
      case keyboardKey.ArrowLeft:
        newFocusTarget = getPreviousFocus(target as HTMLElement);
        event.preventDefault();
        break;
      case keyboardKey.ArrowRight:
        newFocusTarget = getNextFocus(target as HTMLElement);
        event.preventDefault();
        break;
      case keyboardKey.Tab:
        setMenuFocus('activeOption');
        break;
      default:
        break;
    }

    if (newFocusTarget) {
      (newFocusTarget as HTMLElement).focus();
      if (code === keyboardKey.ArrowLeft) {
        setMenuFocus('lastOption');
      }
      if (code === keyboardKey.ArrowRight) {
        setMenuFocus('firstOption');
      }
    }
  };
  return (
    <Wrapper role="tablist" ref={tablistRef} underline={underline} mobile={mobile} {...props}>
      <Underline ref={underlineRef} left={left} width={underlineWidth} aria-hidden />
      <TabsWrapper ref={tabsWrapperRef} onKeyDown={handleTabsWrapperKeyDown}>
        {visibleTabs.map((item: TabWithRefProps) => {
          const { disabled, content, id, icon, badge, ref, width, ...props } = item;
          return (
            <Tab
              ref={ref}
              key={id}
              id={id}
              role="tab"
              aria-selected={id === activeTab}
              tabIndex={id === activeTab ? 0 : -1}
              dimension={dimension}
              disabled={disabled}
              onClick={handleTabClick}
              onKeyUp={handleTabKeyUp}
              {...props}
            >
              <TabContentWrapper dimension={dimension} tabIndex={-1}>
                {icon && icon}
                <TabContent>{content}</TabContent>
                {typeof badge !== 'undefined' && (
                  <Badge
                    data-badge
                    dimension="s"
                    appearance={id === activeTab ? 'info' : disabled ? 'lightDisable' : 'light'}
                  >
                    {badge}
                  </Badge>
                )}
              </TabContentWrapper>
            </Tab>
          );
        })}
      </TabsWrapper>
      {hiddenTabs.length && !mobile ? (
        <TabOverflowMenu
          ref={overflowBtnRef}
          options={hiddenTabs.map(({ ref, ...item }) => item)}
          selected={activeTab}
          dimension={dimension}
          disabled={hiddenTabs.length === hiddenTabs.filter((tab) => tab.disabled).length}
          onChange={(id: string) => {
            onChange(id);
            setUnderlineRect({ left: 0, width: 0 });
          }}
          tabIndex={hiddenTabs?.filter((item) => item.id === activeTab).length ? 0 : -1}
          onMenuReachTop={focusLastTab}
          onMenuReachBottom={focusFirstTab}
          menuFocus={menuFocus}
          setMenuFocus={setMenuFocus}
        />
      ) : null}
    </Wrapper>
  );
};
