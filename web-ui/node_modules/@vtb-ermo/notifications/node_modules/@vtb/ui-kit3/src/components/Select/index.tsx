import type { HTMLAttributes, KeyboardEvent, MouseEvent, ReactElement, ReactNode, RefObject } from 'react';
import * as React from 'react';
import {
  Children,
  cloneElement,
  isValidElement,
  useCallback,
  useEffect,
  useLayoutEffect,
  useRef,
  useState,
} from 'react';
import useInterval from '~/components/common/useInterval';
import styled, { css } from 'styled-components';
import { ReactComponent as ChevronDownOutline } from '@openvtb/admiral-icons/build/system/ChevronDownOutline.svg';
import { ReactComponent as ChevronUpOutline } from '@openvtb/admiral-icons/build/system/ChevronUpOutline.svg';
import { TYPOGRAPHY } from '~/components/Typography';
import { DropDownMenu } from '~/components/DropDownMenu';
import { keyboardKey } from '~/components/common/keyboardKey';
import { PositionInPortal } from './PositionInPortal';
import { refSetter } from '~/components/common/utils/refSetter';

export type SelectDimension = 'xl' | 'm' | 's';
const POSITIONS = ['top', 'bottom'];
type Position = typeof POSITIONS[number];

const heights = css<{ dimension: SelectDimension }>`
  height: ${({ dimension }) => {
    switch (dimension) {
      case 'xl':
        return '56px';
      case 'm':
        return '40px';
      case 's':
        return '32px';
      default:
        return '56px';
    }
  }};
`;

const DropDownContainer = styled.div<{ position?: Position }>`
  position: absolute;
  left: 0;
  right: 0;
  height: 0;
  ${({ position }) => (position === 'top' ? topDropDownPosition : bottomDropDownPosition)}
`;

const topDropDownPosition = css`
  top: 0;

  & ul {
    position: absolute;
    right: 0;
    bottom: 8px;
  }
`;

const bottomDropDownPosition = css`
  bottom: 0;

  & ul {
    position: absolute;
    right: 0;
    top: 8px;
  }
`;

const fillIconMixin = css<{ disabled: boolean }>`
  > * {
    fill: ${({ theme, disabled }) => {
      if (disabled) return theme.color.text.tertiary;
      return theme.color.basic.tertiary;
    }};
  }
`;

const styleText = css<{ dimension: SelectDimension; disabled?: boolean }>`
  font-size: ${({ dimension }) => (dimension === 's' ? 14 : 16)}px;
  line-height: ${({ dimension }) => (dimension === 's' ? 20 : 24)}px;
  font-family: ${TYPOGRAPHY.fontFamily};
`;

const styleIcon = css<{ focused: boolean; disabled?: boolean }>`
  > * {
    fill: ${({ focused, theme, disabled }) => {
      if (focused) return theme.color.basic.press;
      if (disabled) return theme.color.text.tertiary;
      return theme.color.basic.tertiary;
    }};
  }

  &:hover {
    cursor: ${({ disabled }) => (disabled ? 'default' : 'pointer')};
  }

  &:hover > * {
    fill: ${({ theme, disabled }) => (disabled ? theme.color.text.tertiary : theme.color.basic.hover)};
  }
`;

const SelectComponent = styled.div<{ dimension: SelectDimension; disabled: boolean; focused: boolean }>`
  position: relative;
  color: ${({ theme, disabled }) => (disabled ? theme.color.text.tertiary : theme.color.text.primary)};
  display: flex;
  user-select: none;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  border: 0;
  align-items: center;
  justify-content: space-between;
  ${styleText}
  box-sizing: border-box;
  border-radius: 4px;
  height: inherit;
  cursor: ${({ disabled }) => (disabled ? 'default' : 'pointer')};
  ${fillIconMixin}
`;

const Placeholder = styled.div<{ dimension: SelectDimension; focused: boolean; disabled?: boolean }>`
  color: ${({ theme, focused, disabled }) => {
    if (focused) return theme.color.basic.disable;
    if (disabled) return theme.color.text.tertiary;
    return theme.color.text.secondary;
  }};
  pointer-events: none;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  ${styleText}
`;

const StyledDropDown = styled(DropDownMenu)<{ disabled: boolean }>`
  width: 100%;
  position: relative;
  ${fillIconMixin}
`;

const WrapperIcon = styled.div<{ dimension: SelectDimension; focused: boolean; disabled?: boolean }>`
  width: ${({ dimension }) => (dimension === 's' ? 20 : 24)}px;
  display: flex;
  align-items: center;
  ${styleIcon}
`;

const SelectWrapper = styled.div<{
  disabled?: boolean;
  focused: boolean;
  dimension: SelectDimension;
}>`
  box-sizing: border-box;
  padding: 0 ${({ dimension }) => (dimension === 's' ? 12 : 16)}px;
  cursor: ${({ disabled }) => (disabled ? 'default' : 'pointer')};
  background: ${({ theme, disabled }) => (disabled ? theme.color.background.tertiary : theme.color.background.primary)};
  position: relative;
  border-radius: 4px;
  ${heights}

  border-color: ${({ theme, disabled, focused }) => {
    if (focused) return theme.color.basic.press;
    if (disabled) return 'transparent';
    return theme.color.basic.tertiary;
  }};
  border-width: 1px;
  border-style: solid;

  &:hover {
    border-color: ${({ theme, disabled }) => (disabled ? 'transparent' : theme.color.basic.hover)};
  }

  &:focus {
    outline: none;
  }

  &:active {
    outline: none;
  }
`;

const WrapperChild = styled.div`
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
`;

export interface SelectProps extends Omit<HTMLAttributes<HTMLDivElement>, 'onChange'> {
  /** Отключение селекта */
  disabled?: boolean;
  /** Размер Меню */
  dimension?: SelectDimension;
  /** Значение селекта */
  value: string | null;
  /** Функция, которая возвращает реакт-компонент с контентом для отображения в cелекте*/
  renderInputValue?: () => string | ReactNode;
  /** Обработчик для изменения состояния селекта */
  onChange: (value: string) => void;
  /** Колбек на открытие селекта */
  onOpen?: () => void;
  /** Колбек на закрытие селекта */
  onClose?: () => void;
}

export const Select = React.forwardRef<HTMLDivElement, SelectProps>(
  (
    {
      children,
      renderInputValue,
      className,
      disabled = false,
      dimension = 'm',
      value,
      onChange,
      onOpen,
      onClose,
      ...props
    },
    ref,
  ) => {
    const [open, setOpen] = useState(false);
    const [focused, setFocused] = useState(false);
    const refWrapper = useRef<HTMLDivElement>(null);
    const [dropDownPosition, setDropDownPosition] = useState<Position>('bottom');
    const [menu, setMenu] = useState<HTMLUListElement | null>(null);

    const localDropDownRef = useCallback(
      (node: HTMLUListElement) => {
        setMenu(node);
      },
      [open],
    );

    const handleKeyDownItem = (e: KeyboardEvent) => {
      const code = keyboardKey.getCode(e);
      e.preventDefault();
      const value = (e?.currentTarget as HTMLElement).getAttribute('value') ?? '';
      if (code === keyboardKey.Enter || code === keyboardKey[' ']) {
        setOpen(false);
        onClose?.();
        onChange && onChange(value);
        (refWrapper.current as HTMLElement).focus();
      } else if (code === keyboardKey.Escape || code === keyboardKey.Tab) {
        onClose?.();
        setOpen(false);
        (refWrapper.current as HTMLElement).focus();
      }
    };

    const handleClickItem = (e: React.MouseEvent<HTMLElement>, disabled: boolean) => {
      const value = e?.currentTarget.getAttribute('value') ?? '';
      !disabled && onChange && onChange(value);
      setFocused(true);
    };

    let detectedSubGroup = false;

    const renderChildrenDropDown = () => {
      return Children.map(children, (child: React.ReactNode) => {
        if (!isValidElement(child)) {
          return null;
        }

        detectedSubGroup = child.props.children?.some?.((element: ReactElement) => Array.isArray(element));

        if (detectedSubGroup) {
          return child.props.children.flat().map((child: ReactElement) => {
            return cloneElement(child, {
              disabled: disabled || child?.props?.disabled,
              onClick: (e: MouseEvent<HTMLElement>) => handleClickItem(e, child.props.disabled),
              onKeyDown: handleKeyDownItem,
              dimension: dimension === 'xl' ? 'l' : dimension,
              selected: value?.toString() === child.props.value?.toString(),
              ...child.props,
            });
          });
        }

        return cloneElement(child, {
          disabled: disabled || child.props.disabled,
          onClick: (e: React.MouseEvent<HTMLElement>) => handleClickItem(e, child.props.disabled),
          onKeyDown: handleKeyDownItem,
          dimension: dimension === 'xl' ? 'l' : dimension,
          selected: value?.toString() === child.props.value?.toString(),
          ...child.props,
        });
      });
    };

    const clickOutside = () => {
      setOpen(false);
      setFocused(false);
      open && onClose?.();
    };
    const checkMenuPosition = (menu: HTMLUListElement | null, target: RefObject<HTMLDivElement>) => {
      if (menu && target.current && setDropDownPosition) {
        const rect = menu.getBoundingClientRect();
        const viewportHeight = window.innerHeight;

        if (dropDownPosition === 'bottom' && viewportHeight - rect.bottom < 0) {
          setDropDownPosition('top');
        } else if (dropDownPosition === 'top' && viewportHeight - rect.bottom - rect.height - 100 > 0) {
          setDropDownPosition('bottom');
        }
      }
    };

    useLayoutEffect(() => {
      if (open) {
        checkMenuPosition(menu, refWrapper);
      }
    }, [open, menu, refWrapper.current, checkMenuPosition]);

    useInterval(checkMenuPosition, 500, menu, refWrapper);

    useEffect(() => {
      const listener = (event: any) => {
        if (refWrapper?.current?.contains(event.target)) {
          return;
        }
        clickOutside();
      };
      document.addEventListener('click', listener);
      return () => {
        document.removeEventListener('click', listener);
      };
    }, [refWrapper?.current, clickOutside]);

    const Icon = open ? <ChevronUpOutline /> : <ChevronDownOutline />;

    const hendleKeyDown = (e: KeyboardEvent<HTMLDivElement>) => {
      const code = keyboardKey.getCode(e);
      if (code === keyboardKey[' '] && !disabled && !open) {
        setOpen(true);
        setFocused(true);
        e.preventDefault();
        !open ? onOpen?.() : onClose?.();
      } else if (code === keyboardKey.Tab) {
        if (!open) {
          setFocused(false);
        }
      }
      props.onKeyDown?.(e);
    };

    const onClick = (e: MouseEvent<HTMLDivElement>) => {
      if (!disabled) {
        setOpen(!open);
        setFocused(true);
        !open ? onOpen?.() : onClose?.();
      }
      props.onClick?.(e);
    };

    const renderSelectValue = () =>
      props.placeholder && !value ? (
        <Placeholder disabled={disabled} focused={open} dimension={dimension}>
          {props.placeholder}
        </Placeholder>
      ) : (
        renderInputValue?.() ?? <WrapperChild>{value}</WrapperChild>
      );

    const clickWrapperIcon = () => {
      if (!disabled) {
        setOpen(!open);
        setFocused(true);
      }
    };

    return (
      <SelectWrapper
        ref={refSetter(ref, refWrapper)}
        className={className}
        disabled={disabled}
        dimension={dimension}
        focused={focused}
        role="button"
        {...props}
        onKeyDown={hendleKeyDown}
        tabIndex={disabled ? -1 : 0}
        onClick={onClick}
      >
        <SelectComponent focused={focused} dimension={dimension} disabled={disabled}>
          {renderSelectValue()}
          <WrapperIcon onClick={clickWrapperIcon} disabled={disabled} focused={focused} dimension={dimension}>
            {Icon}
          </WrapperIcon>
        </SelectComponent>
        {open && (
          <PositionInPortal targetRef={refWrapper}>
            <DropDownContainer position={dropDownPosition}>
              <StyledDropDown
                ref={localDropDownRef}
                disabled={disabled}
                role="listbox"
                dimension={dimension === 'xl' ? 'l' : dimension}
                tabIndex={-1}
              >
                {renderChildrenDropDown()}
              </StyledDropDown>
            </DropDownContainer>
          </PositionInPortal>
        )}
      </SelectWrapper>
    );
  },
);
