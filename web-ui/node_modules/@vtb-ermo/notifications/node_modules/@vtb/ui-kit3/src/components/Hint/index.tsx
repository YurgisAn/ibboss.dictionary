import type { FC, ReactNode } from 'react';
import React, { HTMLAttributes, useLayoutEffect, useMemo, useReducer, useRef } from 'react';

import type { RefCallback, RefObject } from '../common/utils/handleRef';
import { handleRef } from '../common/utils/handleRef';
import { getScrollableParents } from '../common/utils/getScrollableParents';
import { uid } from '~/components/common/uid';
import { keyboardKey } from '~/components/common/keyboardKey';

import type { Dimension } from './styled';
import { AnchorWrapper } from './styled';
import type { CalculationResult } from './utils';
import { calculateDirection } from './utils';
import { HintContainer } from './HintContainer';
import { initialState, reducer } from './reducer';

type Trigger = 'click' | 'hover';

export interface HintProps extends HTMLAttributes<HTMLDivElement> {
  /** Функция, которая возвращает реакт-компонент с контентом тултипа. Если этому компоненту нужны props, используйте замыкание */
  renderContent: () => ReactNode;
  /** Контейнер, в котором будет отрисован тултип через React.createPortal. По умолчанию тултип отрисовывается в document.body */
  container?: Element | null;
  /** Элемент, относительно которого будет позиционироваться хинт, если позиционирование относительно children не подходит */
  target?: React.MutableRefObject<Element | null | undefined>;
  /** Триггер появления компонента (событие, которое вызывает появление хинта) */
  visibilityTrigger?: Trigger;
  /** Отображение компонента для мобильной версии (менее 640px), хинт адаптируется под ширину экрана */
  isMobile?: boolean;
  /** Размер компонента */
  dimension?: Dimension;
  /** Ссылка на тултип */
  hintRef?: RefCallback<HTMLDivElement> | RefObject<HTMLDivElement> | null;
}

export const Hint: FC<HintProps> = ({
  renderContent,
  container,
  target,
  visibilityTrigger = 'hover',
  isMobile = false,
  dimension = 'l',
  hintRef,
  children,
  className,
  id,
  ...props
}) => {
  const targetRef = target;
  const anchorElementRef = useRef<HTMLDivElement | null>(null);
  const hintElementRef = useRef<HTMLDivElement | null>(null);
  const portal: Element = container || document.body;
  const content = renderContent();
  const anchorId = id || uid();

  const [state, dispatch] = useReducer(reducer, initialState);

  const hideHint = () => dispatch({ type: 'setInvisible' });

  useLayoutEffect(() => {
    const anchorElement = targetRef?.current || anchorElementRef.current;

    if (state.visible && anchorElement && hintElementRef.current) {
      const anchorElementRect = anchorElement.getBoundingClientRect();
      const hintElementRect = hintElementRef.current.getBoundingClientRect();

      if (isMobile) {
        // рассчитываем ширину хинта
        const SAFE_SPACE = 8; // минимальное расстояние от хинта до края экрана
        const hintWidth =
          anchorElementRect.right > window.innerWidth - anchorElementRect.left
            ? anchorElementRect.right
            : window.innerWidth - anchorElementRect.left;
        hintElementRef.current.style.maxWidth = `${hintWidth - SAFE_SPACE}px`;
        dispatch({ type: 'setHintWidth', payload: hintWidth });
      }

      const directionCalculationResult: CalculationResult = calculateDirection(
        anchorElement as HTMLElement,
        hintElementRef.current,
      );
      const calculatedStyles = directionCalculationResult.getStyles(anchorElementRect, hintElementRect);
      hintElementRef.current.style.transform = calculatedStyles;
    }
  }, [
    targetRef?.current,
    anchorElementRef.current,
    hintElementRef.current,
    state.visible,
    state.recalculation,
    state.hintWidth,
    dimension,
    content,
    isMobile,
  ]);

  const attachRef = (node: HTMLDivElement) => handleRef(node, hintRef, hintElementRef);
  const scrollableParents = useMemo(
    () => getScrollableParents(anchorElementRef.current) ?? [],
    [anchorElementRef.current],
  );
  const handleMouseEnter = () => {
    dispatch({ type: 'setVisible' });
  };

  const handleKeyDown = (event: any) => {
    const code = keyboardKey.getCode(event);
    if (code === keyboardKey.Enter || code === keyboardKey[' ']) {
      event.preventDefault();
      dispatch({ type: 'setVisible' });
    }
  };

  return (
    <AnchorWrapper
      onMouseEnter={visibilityTrigger === 'click' ? undefined : handleMouseEnter}
      onMouseLeave={visibilityTrigger === 'click' ? undefined : hideHint}
      onFocus={visibilityTrigger === 'click' ? undefined : handleMouseEnter}
      onBlur={visibilityTrigger === 'click' ? undefined : hideHint}
      onClick={visibilityTrigger === 'click' ? handleMouseEnter : undefined}
      onKeyDown={visibilityTrigger === 'click' ? handleKeyDown : undefined}
      ref={anchorElementRef}
      className={className}
      id={anchorId}
    >
      {children}
      {state.visible && (
        <HintContainer
          ref={attachRef}
          dimension={dimension}
          isMobile={isMobile}
          content={content}
          visibilityTrigger={visibilityTrigger}
          portal={portal}
          scrollableParents={scrollableParents}
          dispatch={dispatch}
          anchorElementRef={anchorElementRef}
          anchorId={anchorId}
          {...props}
        />
      )}
    </AnchorWrapper>
  );
};
