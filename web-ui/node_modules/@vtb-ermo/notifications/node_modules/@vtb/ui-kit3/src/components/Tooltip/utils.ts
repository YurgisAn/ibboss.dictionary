const GAP = 8; // отступ от вызвавшего элемента (anchorElement)

type TooltipPositionType = 'bottom' | 'top' | 'left' | 'right';
export type CalculationResult = {
  check: (anchorElementRect: ClientRect, tooltipRect: ClientRect) => boolean;
  getStyles: (anchorElementRect: ClientRect, tooltipRect: ClientRect) => string;
};

// расположены в порядке приоритета при подборе стороны открытия тултипа
const POSITION_MAPPER: Record<TooltipPositionType, CalculationResult> = {
  bottom: {
    /** проверяем, что тултипу хватит места сверху и по ширине (если ширина тултипа больше
     * ширины вызвавшего элемента (anchorElement), то нужно убедиться, что тултипу хватит
     * места слева и справа */
    check: (anchorElementRect: ClientRect, tooltipRect: ClientRect) => {
      const isEnoughOnBottom = window.innerHeight - anchorElementRect.bottom > GAP + tooltipRect.height;
      const isEnoughOnLeft = anchorElementRect.left + anchorElementRect.width / 2 > tooltipRect.width / 2;
      const isEnoughOnRight =
        window.innerWidth - anchorElementRect.right + anchorElementRect.width / 2 > tooltipRect.width / 2;
      return isEnoughOnBottom && isEnoughOnLeft && isEnoughOnRight;
    },
    getStyles: (anchorElementRect: ClientRect, tooltipRect: ClientRect) => `
      translate3d(${Math.floor(
        anchorElementRect.left + anchorElementRect.width / 2 - tooltipRect.width / 2,
      )}px, ${Math.floor(anchorElementRect.bottom + GAP + window.pageYOffset)}px, 0px)
    `,
  },
  top: {
    /** проверяем, что тултипу хватит места сверху и по ширине (если ширина тултипа больше
     * ширины вызвавшего элемента (anchorElement), то нужно убедиться, что тултипу хватит
     * места слева и справа */
    check: (anchorElementRect: ClientRect, tooltipRect: ClientRect) => {
      const isEnoughOnTop = anchorElementRect.top > GAP + tooltipRect.height;
      const isEnoughOnLeft = anchorElementRect.left + anchorElementRect.width / 2 > tooltipRect.width / 2;
      const isEnoughOnRight =
        window.innerWidth - anchorElementRect.right + anchorElementRect.width / 2 > tooltipRect.width / 2;
      return isEnoughOnTop && isEnoughOnLeft && isEnoughOnRight;
    },
    getStyles: (anchorElementRect: ClientRect, tooltipRect: ClientRect) => `
      translate3d(${Math.floor(
        anchorElementRect.left + anchorElementRect.width / 2 - tooltipRect.width / 2,
      )}px, ${Math.floor(anchorElementRect.top - tooltipRect.height - GAP + window.pageYOffset)}px, 0px)
    `,
  },
  left: {
    /** проверяем, что тултипу хватит места слева и по высоте (если высота тултипа больше
     * высоты вызвавшего элемента (anchorElement), то нужно убедиться, что тултипу хватит
     * места сверху и снизу) */
    check: (anchorElementRect: ClientRect, tooltipRect: ClientRect) => {
      const isEnoughOnLeft = anchorElementRect.left > GAP + tooltipRect.width;
      const isEnoughOnTop = anchorElementRect.top > (tooltipRect.height - anchorElementRect.height) / 2;
      const isEnoughOnBottom =
        window.innerHeight - anchorElementRect.bottom > (tooltipRect.height - anchorElementRect.height) / 2;
      return isEnoughOnLeft && isEnoughOnBottom && isEnoughOnTop;
    },
    getStyles: (anchorElementRect: ClientRect, tooltipRect: ClientRect) => `
      translate3d(${Math.floor(anchorElementRect.left - tooltipRect.width - GAP)}px, ${Math.floor(
      anchorElementRect.top + anchorElementRect.height / 2 - tooltipRect.height / 2 + window.pageYOffset,
    )}px, 0px)
    `,
  },
  right: {
    /** проверяем, что тултипу хватит места справа и по высоте (если высота тултипа больше
     * высоты вызвавшего элемента (anchorElement), то нужно убедиться, что тултипу хватит
     * места сверху и снизу) */
    check: (anchorElementRect: ClientRect, tooltipRect: ClientRect) => {
      const isEnoughOnRight = window.innerWidth - anchorElementRect.right > GAP + tooltipRect.width;
      const isEnoughOnTop = anchorElementRect.top > (tooltipRect.height - anchorElementRect.height) / 2;
      const isEnoughOnBottom =
        window.innerHeight - anchorElementRect.bottom > (tooltipRect.height - anchorElementRect.height) / 2;
      return isEnoughOnRight && isEnoughOnBottom && isEnoughOnTop;
    },
    getStyles: (anchorElementRect: ClientRect, tooltipRect: ClientRect) => `
    translate3d(${Math.floor(anchorElementRect.right + GAP)}px, ${Math.floor(
      anchorElementRect.top + anchorElementRect.height / 2 - tooltipRect.height / 2 + window.pageYOffset,
    )}px, 0px)
    `,
  },
};

export function calculateDirection(anchorElement: HTMLElement, tooltipElement: HTMLElement): CalculationResult {
  const anchorElementRect: ClientRect = anchorElement.getBoundingClientRect();
  const tooltipRect: ClientRect = tooltipElement.getBoundingClientRect();
  const positions = Object.entries(POSITION_MAPPER) as [TooltipPositionType, CalculationResult][];

  const compatiblePositions = positions.filter((kv) => {
    return kv[1].check(anchorElementRect, tooltipRect);
  });

  return compatiblePositions.length ? compatiblePositions[0][1] : POSITION_MAPPER.bottom;
}
