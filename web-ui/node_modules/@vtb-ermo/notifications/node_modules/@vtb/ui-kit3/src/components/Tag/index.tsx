import type { FC, KeyboardEvent, MouseEvent } from 'react';
import React, { HTMLAttributes, useLayoutEffect, useRef, useState } from 'react';
import styled, { css } from 'styled-components';

import { typography } from '../Typography';
import { Tooltip } from '../Tooltip';

const color = css<{ kind: Kind }>`
  background: ${({ kind, theme }) => {
    switch (kind) {
      case 'green':
        return theme.color.status.success;
      case 'blue':
        return theme.color.basic.primary;
      case 'red':
        return theme.color.status.danger;
      case 'orange':
      default:
        return theme.color.status.warn;
    }
  }};
`;

const TAG_HEIGHT = '24px';
const TAG_PADDING = '4px 8px';
const TAG_MARGIN = '8px';
const TAG_BORDER_RADIUS = '4px';
const STATUS_INDICATOR_SIZE = '8px';
const STATUS_INDICATOR_MARGIN = '6px';
const FOCUS_OFFSET = '-4px';
const FOCUS_BORDER_WIDTH = '2px';
const FOCUS_BORDER_RADIUS = '6px';

const Wrapper = styled.button<{ width?: number | string; clickable: boolean }>`
  position: relative;
  box-sizing: border-box;
  height: ${TAG_HEIGHT};
  ${({ width }) => width && `width: ${typeof width === 'number' ? `${width}px` : width};`}
  padding: ${TAG_PADDING};
  margin-top: ${TAG_MARGIN};
  border-radius: ${TAG_BORDER_RADIUS};
  background: ${({ theme }) => theme.color.background.tertiary};

  display: inline-flex;
  align-items: center;
  border: none;
  cursor: ${({ clickable }) => (clickable ? 'pointer' : 'default')};
  ${({ clickable }) => !clickable && 'pointer-events: none;'}

  &:hover,
  &:active {
    background: ${({ theme }) => theme.color.background.tertiaryHover};
  }

  &:focus {
    outline: none;
    &:before {
      content: '';
      position: absolute;
      top: ${FOCUS_OFFSET};
      bottom: ${FOCUS_OFFSET};
      left: ${FOCUS_OFFSET};
      right: ${FOCUS_OFFSET};
      border-radius: ${FOCUS_BORDER_RADIUS};
      border: ${FOCUS_BORDER_WIDTH} solid ${({ theme }) => theme.color.basic.hover};
    }
  }
`;

const Text = styled.span`
  color: ${({ theme }) => theme.color.text.primary};
  user-select: none;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;

  ${typography['Caption/XS']}
`;

const Circle = styled.div<{ kind: Kind }>`
  display: flex;
  flex-shrink: 0;
  width: ${STATUS_INDICATOR_SIZE};
  height: ${STATUS_INDICATOR_SIZE};
  border-radius: 50%;
  margin-right: ${STATUS_INDICATOR_MARGIN};
  ${color}
`;

type Kind = 'neutral' | 'green' | 'blue' | 'red' | 'orange';

export interface TagProps extends HTMLAttributes<HTMLButtonElement> {
  /** Тип тэга */
  kind?: Kind;
  /** Ширина тэга */
  width?: number | string;
  /** Обработчик клика */
  onClick?: (event: MouseEvent<HTMLButtonElement> | KeyboardEvent<HTMLButtonElement>) => void;
}

export const Tag: FC<TagProps> = ({ children, kind = 'neutral', width, onClick, ...props }) => {
  const textRef = useRef(null);
  const [overflow, setOverflow] = useState(false);

  const detectOverflow = (e: any) => e.offsetWidth < e.scrollWidth;

  useLayoutEffect(() => {
    if (textRef.current && detectOverflow(textRef.current) !== overflow) {
      setOverflow(detectOverflow(textRef.current));
    }
  }, [children, width]);

  const renderTag = () => (
    <Wrapper width={width} onClick={onClick} clickable={!!onClick} {...props}>
      {kind !== 'neutral' && <Circle kind={kind} />}
      {children && <Text ref={textRef}>{children}</Text>}
    </Wrapper>
  );

  return overflow ? (
    // не связываю тултип и тег через aria-describedby и id, чтобы содержимое тега не зачитывалось дважды
    <Tooltip renderContent={() => children}>{renderTag()}</Tooltip>
  ) : (
    renderTag()
  );
};
