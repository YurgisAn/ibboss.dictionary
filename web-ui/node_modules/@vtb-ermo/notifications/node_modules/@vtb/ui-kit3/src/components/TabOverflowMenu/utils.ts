import { Dispatch, RefObject, SetStateAction } from 'react';
import { css } from 'styled-components';

export type Position = 'bottom-right' | 'bottom-left' | 'top-right' | 'top-left';

export const checkMenuPosition = (
  menu: HTMLUListElement | null,
  target: RefObject<HTMLButtonElement | null>,
  position: Position,
  setMenuPosition: Dispatch<SetStateAction<Position>>,
) => {
  if (menu && target.current && setMenuPosition) {
    const rect = menu.getBoundingClientRect();
    const targetRect = target.current?.getBoundingClientRect();
    const viewportHeight = window.innerHeight;
    let newPosition: Position = position;

    // replace bottom position with top position, if there is no space under the target
    if (position.indexOf('bottom') > -1 && viewportHeight - rect.bottom < 0) {
      newPosition = newPosition.replace('bottom', 'top') as Position;
    }
    // replace top position with bottom position, if there is enough space under target
    if (position.indexOf('top') > -1 && viewportHeight - targetRect.bottom - 8 >= rect.height) {
      newPosition = newPosition.replace('top', 'bottom') as Position;
    }
    // replace right position with left position, if there is no space to the right of the target
    if (position.indexOf('right') > -1 && rect.right - rect.width < 0) {
      newPosition = newPosition.replace('right', 'left') as Position;
    }
    // replace left position with right position, if there is enough space to the right of the target
    if (position.indexOf('left') > -1 && targetRect.right - rect.width >= 0) {
      newPosition = newPosition.replace('left', 'right') as Position;
    }
    setMenuPosition(newPosition);
  }
};

export const BottomRightPosition = css`
  bottom: 0;
  & ul {
    right: 0px;
    top: 8px;
  }
`;

export const BottomLeftPosition = css`
  bottom: 0;
  & ul {
    left: 0px;
    top: 8px;
  }
`;

export const TopRightPosition = css`
  top: 0;
  & ul {
    right: 0px;
    bottom: 8px;
  }
`;

export const TopLeftPosition = css`
  top: 0;
  & ul {
    left: 0px;
    bottom: 8px;
  }
`;

export const moveFocus = (
  parent: HTMLUListElement | null,
  currentFocus: Element | null,
  calcNextFocus: (
    parent: HTMLUListElement | null,
    child: Element | null,
    stop?: boolean,
    onMenuReachTop?: () => void,
    onMenuReachBottom?: () => void,
  ) => any,
  stop?: boolean,
  onMenuReachTop?: () => void,
  onMenuReachBottom?: () => void,
): void => {
  let wrappedOnce = false;
  let nextFocus = calcNextFocus(parent, currentFocus, stop, onMenuReachTop, onMenuReachBottom);
  while (nextFocus) {
    if (nextFocus === parent?.firstChild) {
      if (wrappedOnce) {
        return;
      }
      wrappedOnce = true;
    }

    if (!nextFocus.hasAttribute('tabindex') || nextFocus.hasAttribute('disabled')) {
      nextFocus = calcNextFocus(parent, nextFocus, stop, onMenuReachTop, onMenuReachBottom);
    } else {
      nextFocus.focus();
      return;
    }
  }
};

export const nextItem = (
  parent: Element | null,
  child: Element | null,
  stop?: boolean,
  onMenuReachTop?: () => void,
  onMenuReachBottom?: () => void,
): Element | null | undefined | ChildNode => {
  if (child?.nextElementSibling) {
    return child.nextElementSibling;
  }
  onMenuReachBottom?.();
  return stop ? null : parent?.firstChild;
};

export const previousItem = (
  parent: Element | null,
  child: Element | null,
  stop?: boolean,
  onMenuReachTop?: () => void,
  onMenuReachBottom?: () => void,
): Element | null | undefined | ChildNode => {
  if (child?.previousElementSibling) {
    return child.previousElementSibling;
  }
  onMenuReachTop?.();
  return stop ? null : parent?.lastChild;
};
