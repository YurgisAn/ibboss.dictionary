import type { KeyboardEvent, MouseEvent, ReactNode } from 'react';
import * as React from 'react';
import { HTMLAttributes, useCallback, useLayoutEffect, useRef, useState } from 'react';
import { ReactComponent as ChevronDownOutline } from '@openvtb/admiral-icons/build/system/ChevronDownOutline.svg';
import styled from 'styled-components';
import { keyboardKey } from '~/components/common/keyboardKey';
import { refSetter } from '~/components/common/utils/refSetter';
import useInterval from '~/components/common/useInterval';
import { useClickOutside } from '~/components/common/hooks/useClickOutside';
import { uid } from '~/components/common/uid';

import { PseudoIcon, PseudoText } from '../Button/skeleton';
import { Button } from '../Button';
import { Spinner } from '../Spinner';
import { DropDownItem } from '../DropDownItem';
import { DropDownMenu } from '../DropDownMenu';

import type { Position } from './position-utils';
import {
  BottomLeftPosition,
  BottomRightPosition,
  checkMenuPosition,
  TopLeftPosition,
  TopRightPosition,
} from './position-utils';
import { PositionInPortal } from './PositionInPortal';

const MenuContainer = styled.div<{ position: Position }>`
  position: absolute;
  left: 0;
  right: 0;
  height: 0;
  ${({ position }) => {
    switch (position) {
      case 'bottom-left':
        return BottomLeftPosition;
      case 'top-right':
        return TopRightPosition;
      case 'top-left':
        return TopLeftPosition;

      case 'bottom-right':
      default:
        return BottomRightPosition;
    }
  }}
`;

const Icon = styled(ChevronDownOutline)<{ $menuOpened: boolean }>`
  transition: all 0.3s;
  ${({ $menuOpened }) => $menuOpened && 'transform: rotate(180deg);'}
`;

const SkeletonText = styled(PseudoText)`
  margin-right: 8px;
`;

type Dimension = 'xl' | 'l' | 'm' | 's';
type Appearance = 'primary' | 'secondary';

export interface MenuButtonItem extends HTMLAttributes<HTMLLIElement> {
  /** Содержимое опции, предназначенное для отображения */
  display: ReactNode;
  /** Отключение опции */
  disabled?: boolean;
  /** Значение опции */
  value?: string | number | undefined;
}

export interface MenuButtonProps extends Omit<HTMLAttributes<HTMLButtonElement>, 'onChange'> {
  /** Массив опций */
  options: Array<MenuButtonItem>;
  /** Выбранная опция */
  selected: string | null;
  /** Колбек на изменение выбранной опции */
  onChange: (id: string) => void;
  /** Колбек на открытие меню */
  onOpen?: () => void;
  /** Колбек на закрытие меню */
  onClose?: () => void;
  /** Размер компонента */
  dimension?: Dimension;
  /** Внешний вид компонента */
  appearance?: Appearance;
  /** Отключение компонента */
  disabled?: boolean;
  /** Состояние loading */
  loading?: boolean;
  /** Состояние skeleton */
  skeleton?: boolean;
}

export const MenuButton = React.forwardRef<HTMLButtonElement, MenuButtonProps>(
  (
    {
      children,
      dimension = 'l',
      appearance = 'primary',
      disabled = false,
      loading = false,
      skeleton = false,
      onClose,
      onOpen,
      options,
      selected,
      onChange,
      ...props
    },
    ref,
  ) => {
    const [menuOpened, setMenuOpened] = useState<boolean>(false);
    const [menuPosition, setMenuPosition] = useState<Position>('bottom-right');
    const btnRef = useRef<HTMLButtonElement>(null);
    const [menu, setMenu] = useState<HTMLUListElement | null>(null);
    const menuRef = useCallback(
      (node: HTMLUListElement) => {
        setMenu(node);
      },
      [menuOpened],
    );

    const menuDimension = dimension === 'xl' ? 'l' : dimension;
    const spinnerDimension = dimension === 's' ? 's' : 'm';

    const reverseMenu = () => {
      setMenuOpened((prevOpened) => {
        prevOpened ? onClose?.() : onOpen?.();
        return !prevOpened;
      });
    };
    const closeMenu = () => {
      setMenuOpened(false);
      onClose?.();
      btnRef.current?.focus();
    };

    useLayoutEffect(() => {
      if (menuOpened) {
        checkMenuPosition(menu, btnRef, menuPosition, setMenuPosition);
      }
    }, [menuOpened, menu, btnRef.current, menuPosition, setMenuPosition]);

    useInterval(checkMenuPosition, 500, menu, btnRef, menuPosition, setMenuPosition);
    useClickOutside([btnRef.current, menu], closeMenu);

    const handleBtnKeyDown = (e: KeyboardEvent<HTMLButtonElement>) => {
      const code = keyboardKey.getCode(e);
      if (code === keyboardKey.ArrowDown || code === keyboardKey.Enter || code === keyboardKey[' ']) {
        setMenuOpened(true);
        onOpen?.();
        e.preventDefault();
      }
    };
    const handleMenuKeyDown = (e: KeyboardEvent<HTMLUListElement>) => {
      const code = keyboardKey.getCode(e);
      if (code === keyboardKey.Escape) {
        closeMenu();
      }
    };
    const renderContent = () => {
      if (loading) return <Spinner dimension={spinnerDimension} />;
      if (skeleton)
        return (
          <>
            <SkeletonText dimension={dimension} appearance={appearance} />
            <PseudoIcon dimension={dimension} appearance={appearance} />
          </>
        );
      return (
        <>
          {React.Children.toArray(children).map((child) =>
            typeof child === 'string' ? <span key={uid()}>{child}</span> : child,
          )}
          <Icon $menuOpened={menuOpened} aria-hidden />
        </>
      );
    };
    return (
      <>
        <Button
          {...props}
          ref={refSetter(ref, btnRef)}
          dimension={dimension}
          appearance={appearance}
          disabled={loading || skeleton ? true : disabled}
          onKeyDown={handleBtnKeyDown}
          onClick={reverseMenu}
          aria-expanded={menuOpened}
        >
          {renderContent()}
        </Button>
        {menuOpened && !loading && !skeleton && (
          <PositionInPortal targetRef={btnRef} position={menuPosition}>
            <MenuContainer position={menuPosition}>
              <DropDownMenu ref={menuRef} dimension={menuDimension} onKeyDown={handleMenuKeyDown} role="listbox">
                {options.map(({ display, disabled: optionDisabled, id, ...props }) => {
                  const handleClick = (e: MouseEvent<HTMLLIElement>) => {
                    onChange(e.currentTarget.id);
                    closeMenu();
                  };
                  const handleKeyDown = (e: KeyboardEvent<HTMLLIElement>) => {
                    const code = keyboardKey.getCode(e);
                    if (code === keyboardKey.Enter || code === keyboardKey[' ']) {
                      onChange(e.currentTarget.id);
                      closeMenu();
                      e.preventDefault();
                    }
                  };
                  return (
                    <DropDownItem
                      {...props}
                      key={id}
                      id={id}
                      dimension={menuDimension}
                      disabled={disabled || optionDisabled}
                      selected={selected === id}
                      role="option"
                      onClick={handleClick}
                      onKeyDown={handleKeyDown}
                    >
                      {display}
                    </DropDownItem>
                  );
                })}
              </DropDownMenu>
            </MenuContainer>
          </PositionInPortal>
        )}
      </>
    );
  },
);
