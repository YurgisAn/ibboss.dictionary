import type { HTMLAttributes, KeyboardEvent, MouseEvent, ReactElement, ReactNode } from 'react';
import * as React from 'react';
import { Children, cloneElement, Fragment, isValidElement, useEffect, useRef, useState } from 'react';
import styled, { css } from 'styled-components';
import { ReactComponent as ChevronDownOutline } from '@openvtb/admiral-icons/build/system/ChevronDownOutline.svg';
import { ReactComponent as ChevronUpOutline } from '@openvtb/admiral-icons/build/system/ChevronUpOutline.svg';
import { TYPOGRAPHY } from '~/components/Typography';
import { DropDownMenu } from '~/components/DropDownMenu';
import { keyboardKey } from '~/components/common/keyboardKey';
import { PositionInPortal } from './PositionInPortal';
import { refSetter } from '~/components/common/utils/refSetter';
import { Chips } from '../Chips';

export type MultiSelectDimension = 'xl' | 'm' | 's';

const heights = css<{ dimension: MultiSelectDimension }>`
  height: ${({ dimension }) => {
    switch (dimension) {
      case 'xl':
        return '54px';
      case 'm':
        return '38px';
      case 's':
        return '30px';
      default:
        return '54px';
    }
  }};
`;

const styleText = css<{ dimension: MultiSelectDimension; disabled?: boolean }>`
  font-size: ${({ dimension }) => (dimension === 's' ? 14 : 16)}px;
  line-height: ${({ dimension }) => (dimension === 's' ? 20 : 24)}px;
  font-family: ${TYPOGRAPHY.fontFamily};
`;

const styleIcon = css<{ focused: boolean; disabled?: boolean }>`
  > * {
    fill: ${({ focused, theme, disabled }) => {
      if (focused) return theme.color.basic.press;
      if (disabled) return theme.color.text.tertiary;
      return theme.color.basic.tertiary;
    }};
  }

  &:hover {
    cursor: ${({ disabled }) => (disabled ? 'default' : 'pointer')};
  }

  &:hover > * {
    fill: ${({ theme, disabled }) => (disabled ? theme.color.text.tertiary : theme.color.basic.hover)};
  }
`;

const SelectComponent = styled.div<{ dimension: MultiSelectDimension; disabled?: boolean; focused: boolean }>`
  white-space: nowrap;
  position: relative;
  color: ${({ theme, disabled }) => (disabled ? theme.color.text.tertiary : theme.color.text.primary)};
  display: flex;
  user-select: none;
  flex-flow: nowrap;
  cursor: pointer;
  border: 0;
  pointer-events: none;
  align-items: center;
  padding-left: 16px;
  justify-content: space-between;
  ${styleText}
  border-sizing: border-box;
  border-radius: 4px;
  height: inherit;
  cursor: ${({ disabled }) => (disabled ? 'default' : 'pointer')};

  > * {
    fill: ${({ theme, disabled }) => {
      if (disabled) return theme.color.text.tertiary;
      return theme.color.basic.tertiary;
    }};
  }
`;

const Placeholder = styled.div<{ dimension: MultiSelectDimension; focused: boolean; disabled?: boolean }>`
  color: ${({ theme, focused, disabled }) => {
    if (focused) return theme.color.basic.disable;
    if (disabled) return theme.color.text.tertiary;
    return theme.color.text.secondary;
  }};
  pointer-events: none;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  ${styleText}
`;

const StyledDropDown = styled(DropDownMenu)<{ disabled: boolean }>`
  width: 100%;
  position: relative;

  > * {
    fill: ${({ theme, disabled }) => {
      if (disabled) return theme.color.text.tertiary;
      return theme.color.basic.tertiary;
    }};
  }
`;

const WrapperIcon = styled.div<{ dimension: MultiSelectDimension; focused: boolean; disabled?: boolean }>`
  padding-right: ${({ dimension }) => (dimension === 's' ? 16 : 20)}px;
  display: flex;
  align-items: center;
  ${styleIcon}
`;

const SelectWrapper = styled.div<{
  disabled?: boolean;
  focused: boolean;
  dimension: MultiSelectDimension;
}>`
  cursor: ${({ disabled }) => (disabled ? 'default' : 'pointer')};
  background: ${({ theme, disabled }) => (disabled ? theme.color.background.tertiary : theme.color.background.primary)};
  position: relative;
  border-radius: 4px;
  ${heights}
  border-color: ${({ theme, disabled, focused }) => {
    if (focused) return theme.color.basic.press;
    if (disabled) return 'transparent';
    return theme.color.basic.tertiary;
  }};
  border-width: 1px;
  border-style: solid;

  &:hover {
    border-color: ${({ theme, disabled }) => (disabled ? 'transparent' : theme.color.basic.hover)};
  }

  &:focus {
    outline: 1;
  }

  &:active {
    outline: 0;
  }
`;

const WrapperChip = styled.div`
  align-items: center;
  box-sizing: border-box;
  display: flex;
  flex: 1;
  flex-wrap: wrap;
  overflow: hidden;
  position: relative;
  height: 32px;
  padding-right: 46px;
  pointer-events: none;
`;

const CounterChip = styled(Chips)`
  box-sizing: border-box;
  display: flex;
  align-items: center;
  flex: 0 0 auto;
  margin: ${(props) => (props.dimension === 's' ? `4px 8px 4px 0` : `2px 8px 4px 0`)};
  margin-right: ${(props) => (props.dimension === 's' ? -34 : -45)}px;
`;

const ChipItemWrapper = styled.div<{ dimension: MultiSelectDimension }>`
  box-sizing: border-box;
  display: flex;
  align-items: center;
  flex: 0 0 auto;
  margin: ${(props) => (props.dimension === 's' ? `4px 8px 4px 0` : `2px 8px 4px 0`)};
`;

export interface MultiSelectProps extends Omit<HTMLAttributes<HTMLDivElement>, 'onChange'> {
  /** Отключение селекта */
  disabled?: boolean;
  /** Размер Меню */
  dimension?: MultiSelectDimension;
  /** Значение селекта */
  value: string[];
  /** Функция, которая возвращает реакт-компонент с контентом для отображения в cелекте*/
  renderInputValue?: () => string | ReactNode | Element;
  /** Обработчик для изменения состояния селекта */
  onChange: (value: string[]) => void;
  /** Ссылка на Дропдаун */
  dropDownRef?: any;
  /** Колбек на открытие селекта */
  onOpen?: () => void;
  /** Колбек на закрытие селекта */
  onClose?: () => void;
}

export const MultiSelect = React.forwardRef<HTMLDivElement, MultiSelectProps>(
  (
    {
      children,
      renderInputValue,
      className,
      disabled = false,
      dimension = 'xl',
      value,
      onChange,
      dropDownRef,
      onOpen,
      onClose,
      ...props
    },
    ref,
  ) => {
    const [open, setOpen] = useState(false);
    const [focused, setFocused] = useState(false);
    const localDropDownRef = useRef<HTMLUListElement>(null);
    const refPortal = useRef<HTMLDivElement>(null);

    const refWrapper = useRef<HTMLDivElement>(null);

    const detectedDuplicate = (targetValue: string, array: string[]) => {
      return array.indexOf(targetValue) === array.lastIndexOf(targetValue)
        ? array
        : array.filter((item: string) => item !== targetValue);
    };

    const handleKeyDownItem = (e: KeyboardEvent) => {
      const code = keyboardKey.getCode(e);
      e.preventDefault();
      if (code === keyboardKey.Enter || code === keyboardKey[' ']) {
        const targetValue = (e?.currentTarget as HTMLElement).getAttribute('value') ?? '';
        targetValue && onChange && onChange(detectedDuplicate(targetValue, [...value, targetValue]));
      } else if (code === keyboardKey.Escape || code === keyboardKey.Tab) {
        onClose?.();
        setOpen(false);
        (refWrapper.current as HTMLElement).focus();
      }
    };

    const handleClickItem = (e: MouseEvent, disabled: boolean) => {
      const targetValue = (e?.currentTarget as HTMLElement).getAttribute?.('value') ?? '';
      targetValue && !disabled && onChange && onChange(detectedDuplicate(targetValue, [...value, targetValue]));
    };

    let detectedSubGroup = false;

    const renderChildrenDropDown = () => {
      return Children.map(children, (child: React.ReactNode) => {
        if (!isValidElement(child)) {
          return null;
        }

        detectedSubGroup = child.props.children?.some?.((element: ReactElement) => Array.isArray(element));
        if (detectedSubGroup) {
          return child.props.children.flat().map((child: ReactElement) => {
            return cloneElement(child, {
              disabled: disabled || child?.props?.disabled,
              onMouseDown: (e: MouseEvent) => handleClickItem(e, child.props.disabled),
              onKeyDown: handleKeyDownItem,
              dimension: dimension === 'xl' ? 'l' : dimension,
              selected: value.length === 0 ? false : value.includes(child?.props?.value?.toString?.()),
              ...child.props,
            });
          });
        }

        return cloneElement(child, {
          disabled: disabled || child.props.disabled,
          onMouseDown: (e: MouseEvent) => handleClickItem(e, child.props.disabled),
          onKeyDown: handleKeyDownItem,
          dimension: dimension === 'xl' ? 'l' : dimension,
          selected: value.length === 0 ? false : value.includes(child?.props?.value?.toString?.()),
          ...child.props,
        });
      });
    };

    const outsideClick = () => {
      setOpen(false);
      setFocused(false);
      open && onClose?.();
    };

    useEffect(() => {
      const listener = (event: any) => {
        if (
          refPortal?.current?.contains(event.target) ||
          refWrapper?.current?.contains(event.target) ||
          localDropDownRef?.current?.contains(event.target)
        ) {
          return;
        }
        outsideClick();
      };
      document.addEventListener('mousedown', listener);
      document.addEventListener('touchstart', listener);
      return () => {
        document.removeEventListener('mousedown', listener);
        document.removeEventListener('touchstart', listener);
      };
    }, [refPortal?.current, refWrapper?.current, localDropDownRef?.current, outsideClick]);

    const Icon = open ? <ChevronUpOutline width={24} /> : <ChevronDownOutline width={24} />;

    const hendleKeyDown = (e: KeyboardEvent<HTMLDivElement>) => {
      const code = keyboardKey.getCode(e);
      if (code === keyboardKey[' '] && !disabled && (e.target as HTMLElement) === e.currentTarget) {
        setOpen(!open);
        setFocused(true);
        e.preventDefault();
        !open ? onOpen?.() : onClose?.();
      } else if (code === keyboardKey.Escape) {
        setOpen(false);
      } else if (code === keyboardKey.Tab) {
        if (!open) {
          setFocused(false);
        }
      }
      props.onKeyDown?.(e);
    };

    const onClick = (e: MouseEvent<HTMLDivElement>) => {
      if (e.currentTarget === e.target) {
        e.preventDefault();
        e.stopPropagation();
        if (!disabled) {
          !open ? onOpen?.() : onClose?.();
          setOpen(!open);
          setFocused(true);
        }
        props.onClick?.(e);
      }
    };

    const defaultRender = () => {
      const sizeChips = dimension === 's' ? 's' : 'm';
      const setCounterChip = (index: number) => ' + ' + index;
      const iconClick = (id: number) => {
        onChange(value.filter((d, index) => index !== id));
      };
      return (
        <WrapperChip>
          {value.map((d, index) => {
            return (
              <Fragment key={index}>
                <CounterChip tabIndex={-1} disabled={disabled} dimension={sizeChips} appearance="filled">
                  {setCounterChip(value.length - index)}
                </CounterChip>
                <ChipItemWrapper dimension={dimension}>
                  <Chips
                    tabIndex={-1}
                    disabled={disabled}
                    dimension={sizeChips}
                    appearance="filled"
                    onClose={() => iconClick(index)}
                  >
                    {d}
                  </Chips>
                </ChipItemWrapper>
              </Fragment>
            );
          })}
        </WrapperChip>
      );
    };

    const renderSelectValue = () =>
      props.placeholder && value.length === 0 ? (
        <Placeholder disabled={disabled} focused={open} dimension={dimension}>
          {props.placeholder}
        </Placeholder>
      ) : (
        renderInputValue?.() ?? defaultRender()
      );

    const clickWrapperIcon = (e: MouseEvent) => {
      if (!disabled) {
        !open ? onOpen?.() : onClose?.();
        e.preventDefault();
        setOpen(!open);
        setFocused(true);
        e.stopPropagation();
      }
    };

    return (
      <SelectWrapper
        ref={refSetter(ref, refWrapper)}
        className={className}
        disabled={disabled}
        dimension={dimension}
        focused={focused}
        {...props}
        onKeyDown={hendleKeyDown}
        onClick={onClick}
        tabIndex={disabled ? -1 : 0}
      >
        <SelectComponent focused={focused} dimension={dimension} disabled={disabled}>
          {renderSelectValue()}
          <WrapperIcon onMouseDown={clickWrapperIcon} disabled={disabled} focused={focused} dimension={dimension}>
            {Icon}
          </WrapperIcon>
        </SelectComponent>
        {open && (
          <div ref={refPortal} onClick={(e) => e.preventDefault()}>
            <PositionInPortal open={open} parentRef={refWrapper} targetRef={refPortal}>
              <StyledDropDown
                disabled={disabled}
                ref={refSetter(dropDownRef, localDropDownRef)}
                dimension={dimension === 'xl' ? 'l' : dimension}
                role="listbox"
                tabIndex={-1}
              >
                {renderChildrenDropDown()}
              </StyledDropDown>
            </PositionInPortal>
          </div>
        )}
      </SelectWrapper>
    );
  },
);
