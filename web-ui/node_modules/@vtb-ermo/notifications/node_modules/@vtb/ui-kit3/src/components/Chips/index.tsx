import React, { FC, HTMLAttributes, MutableRefObject, ReactNode, useEffect, useRef, useState } from 'react';
import { Tooltip } from '../Tooltip';
import { ReactComponent as CloseOutline } from '@openvtb/admiral-icons/build/service/CloseOutline.svg';
import { TYPOGRAPHY } from '~/components/Typography';
import styled, { css } from 'styled-components';

export type ChipDimension = 's' | 'm';
export type ChipAppearance = 'filled' | 'outlined';

const heights = css<{ dimension: ChipDimension }>`
  height: ${({ dimension }) => {
    switch (dimension) {
      case 'm':
        return '28px';
      case 's':
        return '24px';
      default:
        return '28px';
    }
  }};
`;

const heightIcons = css<{ dimension: ChipDimension }>`
  height: ${({ dimension }) => {
    switch (dimension) {
      case 'm':
        return '18px';
      case 's':
        return '12px';
      default:
        return '16px';
    }
  }};
`;

const widthIcons = css<{ dimension: ChipDimension }>`
  width: ${({ dimension }) => {
    switch (dimension) {
      case 'm':
        return '18px';
      case 's':
        return '12px';
      default:
        return '16px';
    }
  }};
`;

const paddings = css<{ dimension: ChipDimension }>`
  padding: ${({ dimension }) => {
    switch (dimension) {
      case 'm':
        return '6px 12px';
      case 's':
        return '4px 8px';
      default:
        return '6px 12px';
    }
  }};
`;

const typography = css<{
  dimension: ChipDimension;
  disabled?: boolean;
  selected?: boolean;
  appearance?: ChipAppearance;
}>`
  font-family: ${TYPOGRAPHY.fontFamily};
  font-style: normal;
  font-weight: normal;
  font-size: ${({ dimension }) => (dimension === 's' ? '12px' : '14px')};
  line-height: ${({ dimension }) => (dimension === 's' ? '16px' : '20px')};
  font-feature-settings: 'tnum' on, 'lnum' on;
  color: ${({ theme, appearance, disabled, selected }) => {
    if (disabled && !selected) return theme.color.text.tertiary;

    if (selected || (selected && disabled)) return theme.color.text.staticWhite;

    return appearance === 'filled' ? theme.color.text.primary : theme.color.basic.primary;
  }};
  &:hover {
    color: ${({ theme, appearance, selected }) => {
      if (selected) return theme.color.text.staticWhite;
      if (appearance === 'filled') return theme.color.text.primary;
      else theme.color.basic.hover;
    }}
`;

const colorsBorderAndBackground = css<{
  dimension: ChipDimension;
  disabled?: boolean;
  selected?: boolean;
  appearance?: ChipAppearance;
}>`
  background-color: ${({ theme, appearance, selected, disabled }) => {
    if (selected && !disabled) {
      return theme.color.basic.primary;
    }
    if (selected && disabled) return theme.color.basic.disable;
    return appearance === 'filled' ? theme.color.background.tertiary : theme.color.background.primary;
  }};

  border: 1px solid
    ${({ theme, appearance, disabled }) => {
      if (disabled) return theme.color.background.tertiary;
      if (appearance === 'filled') return 'transparent';
      else return theme.color.basic.primary;
    }};

  border-radius: 16px;
  &:hover {
    background-color: ${({ theme, appearance, selected }) => {
      if (selected) return theme.color.basic.hover;
      if (appearance === 'filled') return theme.color.background.tertiaryHover;
      else return theme.color.background.secondary;
    }};
  }

  &:active {
    color: ${({ theme, appearance }) => (appearance === 'filled' ? theme.color.text.primary : theme.color.basic.press)};
    background-color: ${({ theme, appearance, selected }) => {
      if (selected) {
        return theme.color.basic.primary;
      }
      return appearance === 'filled' ? theme.color.background.tertiaryHover : theme.color.background.secondary;
    }};
  }

  &:focus-visible {
    outline: 0;
    &:before {
      border: 2px solid ${({ theme }) => theme.color.basic.hover};
      border-radius: 20px;
      content: '';
      display: block;
      position: absolute;
      top: -5px;
      left: -5px;
      right: -5px;
      bottom: -5px;
      pointer-events: none;
    }
  }
`;

export const ChipComponent = styled.div<{
  disabled?: boolean;
  dimension: ChipDimension;
  appearance?: ChipAppearance;
  selected?: boolean;
  defaultChip?: boolean;
}>`
  display: inline-flex;
  align-items: center;
  box-sizing: border-box;
  position: relative;
  max-width: 190px;
  user-select: none;
  pointer-events: ${({ disabled }) => (disabled ? 'none' : 'auto')};
  fill: ${({ theme, appearance, disabled }) =>
    appearance === 'filled' || disabled ? theme.color.basic.tertiary : theme.color.basic.primary};
  cursor: ${({ defaultChip, disabled }) => (defaultChip && !disabled ? 'pointer' : 'default')};
  ${colorsBorderAndBackground}
  ${heights}
  ${paddings}
  ${typography}
`;

export const CloseIcon = styled(CloseOutline)<{
  disabled?: boolean;
  dimension: ChipDimension;
}>`
  margin-left: 12px;
  cursor: ${({ disabled }) => (disabled ? 'default' : 'pointer')};
  ${heightIcons}
  ${widthIcons}

  &:hover {
    outline: none;
    cursor: pointer;
    fill: ${({ theme }) => theme.color.basic.hover};
  }
  &:active {
    outline: none;
    border: none;
    fill: ${({ theme }) => theme.color.basic.press};
  }
`;

const WrapperChildren = styled.div<{
  appearance?: ChipAppearance;
  disabled?: boolean;
  selected?: boolean;
  dimension: ChipDimension;
}>`
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;

  & svg {
    ${heightIcons}
    ${widthIcons}
    fill: ${({ theme, appearance, disabled, selected }) => {
      if (selected) {
        return theme.color.background.primary;
      }
      return appearance === 'filled' || disabled ? theme.color.basic.tertiary : theme.color.basic.primary;
    }};
  }
`;

export interface ChipsProps extends HTMLAttributes<HTMLDivElement> {
  /** Делает высоту компонента больше или меньше обычной */
  dimension?: ChipDimension;
  /** Отключение чипса */
  disabled?: boolean;
  /** Вид чипсов */
  appearance?: ChipAppearance;
  /** Выбранная чипса */
  selected?: boolean;
  /** Добавляет иконку для удаления чипсов */
  onClose?: () => void;
  /** Функция, которая возвращает реакт-компонент с контентом тултипа. Если этому компоненту нужны props, используйте замыкание */
  renderContentTooltip?: () => ReactNode;
}

export const Chips: FC<ChipsProps> = ({
  dimension = 'm',
  disabled,
  appearance = 'outlined',
  selected,
  onClose,
  children,
  renderContentTooltip = () => '',
  ...props
}) => {
  const defaultChip = selected !== undefined;
  const [withTooltip, setTooltip] = useState(false);

  const refItems: MutableRefObject<HTMLDivElement | null> = useRef(null);

  useEffect(() => {
    if (refItems?.current && refItems?.current?.offsetWidth <= refItems?.current?.scrollWidth) {
      setTooltip(refItems?.current.offsetWidth < refItems?.current.scrollWidth);
    }
  }, [setTooltip, refItems.current]);

  const handleClick = () => {
    if (!disabled) {
      onClose?.();
    }
  };

  const Chip = (
    <ChipComponent
      dimension={dimension}
      disabled={disabled}
      appearance={appearance}
      selected={selected}
      defaultChip={defaultChip}
      {...props}
      tabIndex={props.tabIndex ?? 0}
    >
      <WrapperChildren
        dimension={dimension}
        disabled={disabled}
        appearance={appearance}
        selected={selected}
        ref={refItems}
      >
        {children}
      </WrapperChildren>
      {onClose && <CloseIcon dimension={dimension} disabled={disabled} onClick={disabled ? undefined : handleClick} />}
    </ChipComponent>
  );

  return withTooltip ? <Tooltip renderContent={renderContentTooltip}>{Chip}</Tooltip> : Chip;
};
