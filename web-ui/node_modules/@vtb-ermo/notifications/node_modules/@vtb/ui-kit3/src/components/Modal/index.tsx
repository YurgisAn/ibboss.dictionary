import type { FC, KeyboardEvent, MouseEvent } from 'react';
import React, { forwardRef, HTMLAttributes, useEffect, useLayoutEffect, useRef, useState } from 'react';
import ReactDOM from 'react-dom';
import styled, { css } from 'styled-components';
import { ReactComponent as CloseOutline } from '@openvtb/admiral-icons/build/service/CloseOutline.svg';
import { keyboardKey } from '~/components/common/keyboardKey';
import { refSetter } from '~/components/common/utils/refSetter';
import { hexToRgba } from '~/components/common/utils/hexToRgba';
import { getKeyboardFocusableElements } from '~/components/common/utils/getKeyboardFocusableElements';

import { typography } from '../Typography';

type Dimension = 'xl' | 'l' | 'm' | 's';

const Overlay = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  transition: opacity 0.3s ease 0s;
  background-color: ${({ theme }) => hexToRgba(theme.color.basic.secondary, 0.6)};
  backdrop-filter: blur(8px);
  z-index: ${({ theme }) => theme.zIndex.modal};
`;

const width = css<{ dimension: Dimension; mobile?: boolean }>`
  width: ${({ dimension, mobile }) => {
    // 16px on left and right side
    if (mobile) return 'calc(100% - 32px)';
    switch (dimension) {
      case 's':
        return '384px';
      case 'm':
        return '488px';
      case 'xl':
        return '800px';
      case 'l':
      default:
        return '592px';
    }
  }};
`;

const Title = styled.h5<{ mobile?: boolean }>`
  ${typography['Main/S']}
  margin: 0 32px 16px 0;
`;

const Content = styled.div<{ $overflow?: boolean }>`
  overflow-x: hidden;
  overflow-y: auto;
  ${({ $overflow }) => $overflow && 'padding-right: 24px;'}
`;

const ButtonPanel = styled.div<{ mobile?: boolean }>`
  display: flex;
  flex-direction: row-reverse;
  margin-top: 24px;
  & > button {
    margin-right: 16px;
  }
  & > button:first-child {
    margin-right: 0;
  }
`;

const ModalComponent = styled.div<{ dimension: Dimension; mobile?: boolean }>`
  position: absolute;
  box-sizing: border-box;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  padding: ${({ mobile }) => (mobile ? '20px 16px 24px 16px' : '20px 24px 24px 24px')};
  ${width}
  max-height: ${({ mobile }) => (mobile ? '84vh' : '90vh')};
  background-color: ${({ theme }) => theme.color.background.primary};
  ${({ theme }) => theme.shadow.ClickableHover}
  border-radius: 8px;
  ${({ mobile }) => (mobile ? typography['Additional/S'] : typography['Additional/L'])}
  color: ${({ theme }) => theme.color.text.primary};

  ${({ mobile }) =>
    mobile &&
    `
    & > ${Title} {
      ${typography['Main/XS']}
      margin: 0 30px 16px 0;
    }
    & > ${ButtonPanel} {
      flex-direction: column-reverse;
      & > button {
        width: 100%;
        margin-bottom: 16px;
      }
      & > button:first-child {
          margin-bottom: 0;
      }
    }
  `}
`;

const CloseButton = styled.button<{ mobile?: boolean }>`
  position: absolute;
  top: 20px;
  right: ${({ mobile }) => (mobile ? 16 : 24)}px;
  flex-shrink: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  box-sizing: border-box;
  cursor: pointer;
  outline: none;
  border: 0;
  padding: 0;
  width: 24px;
  height: 24px;
  background: transparent;
  -webkit-tap-highlight-color: transparent;
  ${({ theme }) => `
    & svg {
      fill: ${theme.color.basic.tertiary};
    }

    &:hover,
    &:focus {
      & svg {
        fill: ${theme.color.basic.hover};
      }
    }

    &:active {
      & svg {
        fill: ${theme.color.basic.press};
      }
    }
  `}
`;

export const ModalTitle: FC<HTMLAttributes<HTMLHeadingElement>> = ({ children, ...props }) => {
  return <Title {...props}>{children}</Title>;
};

export const ModalContent: FC<HTMLAttributes<HTMLDivElement>> = ({ children, ...props }) => {
  const contentRef = useRef<HTMLDivElement | null>(null);
  const [overflow, setOverflow] = useState(false);

  const detectOverflow = (e: any) => {
    return e.clientHeight < e.scrollHeight;
  };

  useLayoutEffect(() => {
    if (contentRef.current && detectOverflow(contentRef.current) !== overflow) {
      setOverflow(detectOverflow(contentRef.current));
    }
  }, [children]);

  return (
    <Content ref={contentRef} $overflow={overflow} {...props}>
      {children}
    </Content>
  );
};

export const ModalButtonPanel: FC<HTMLAttributes<HTMLDivElement>> = ({ children, ...props }) => {
  return <ButtonPanel {...props}>{children}</ButtonPanel>;
};

export interface ModalProps extends HTMLAttributes<HTMLDivElement> {
  /** Размер компонента */
  dimension?: Dimension;
  /** Контейнер, в котором происходит размещение модального окна (BODY по умолчанию) */
  container?: Element;
  /** Мобильная версия компонента */
  mobile?: boolean;
  /** Закрытие на нажатие клавиши Escape */
  closeOnEscapeKeyDown?: boolean;
  /** Закрытие на клик извне */
  closeOnOutsideClick?: boolean;
  /** Обработчик закрытия компонента */
  onClose?: () => void;
}

export const Modal: FC<ModalProps> = forwardRef<HTMLDivElement, ModalProps>(
  (
    { dimension = 'l', container, mobile, onClose, closeOnEscapeKeyDown, closeOnOutsideClick, children, ...props },
    ref,
  ) => {
    const modalRef: any = useRef<HTMLDivElement>(null);
    const overlayRef = useRef<HTMLDivElement>(null);
    const previousFocusedElement: any = useRef(null);
    const [firstFocusableChild, setFirstFocusableChild] = useState<any>();
    const [lastFocusableChild, setLastFocusableChild] = useState<any>();

    useEffect(() => {
      previousFocusedElement.current = document.activeElement;
      return () => {
        // return focus on close/unmount of modal
        previousFocusedElement.current?.focus();
      };
    }, []);

    useLayoutEffect(() => {
      if (modalRef.current) {
        const focusableEls = getKeyboardFocusableElements(modalRef.current);
        setFirstFocusableChild(focusableEls[0]);
        setLastFocusableChild(focusableEls[focusableEls.length - 1]);
        firstFocusableChild?.focus();
      }
    }, [modalRef.current, children]);

    const handleKeyDown = (event: KeyboardEvent<HTMLDivElement>) => {
      event.stopPropagation();
      const code = keyboardKey.getCode(event);
      if (code === keyboardKey.Escape && closeOnEscapeKeyDown) {
        event.preventDefault();
        onClose?.();
      } else if (code === keyboardKey.Tab) {
        // focus trap
        if (code === keyboardKey.Shift) {
          /* shift + tab */
          if (document.activeElement === firstFocusableChild) {
            lastFocusableChild.focus();
            event.preventDefault();
          }
        } /* tab */ else {
          if (document.activeElement === lastFocusableChild) {
            firstFocusableChild.focus();
            event.preventDefault();
          }
        }
      }
    };

    const handleOverflayClick = (event: MouseEvent<HTMLDivElement>) => {
      closeOnOutsideClick && event.target === overlayRef.current && onClose?.();
    };

    const handleCloseBtnClick = (event: MouseEvent<HTMLButtonElement> | KeyboardEvent<HTMLButtonElement>) => {
      event.stopPropagation();
      onClose?.();
    };

    return ReactDOM.createPortal(
      <Overlay ref={overlayRef} onClick={handleOverflayClick}>
        <ModalComponent
          ref={refSetter(ref, modalRef)}
          role="dialog"
          aria-modal
          dimension={dimension}
          mobile={mobile}
          onKeyDown={handleKeyDown}
          {...props}
        >
          {children}
          {onClose && (
            <CloseButton aria-label="Закрыть модальное окно" mobile={mobile} onClick={handleCloseBtnClick}>
              <CloseOutline width={24} height={24} aria-hidden />
            </CloseButton>
          )}
        </ModalComponent>
      </Overlay>,
      container || document.body,
    );
  },
);
