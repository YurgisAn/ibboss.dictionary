import React, { FC, useCallback, useEffect, useRef, useState } from 'react';
import { createPortal } from 'react-dom';
import styled, { css } from 'styled-components';
import observeRect from '~/components/common/observeRect';
import useInterval from '~/components/common/useInterval';

const POSITIONS = ['top', 'bottom'];
type Position = typeof POSITIONS[number];

const PositionedPortalContainer = styled.div`
  position: fixed;
  overflow: visible;
  z-index: ${({ theme }) => theme.zIndex.dropdown};
`;

const DropDownContainer = styled.div<{ position?: Position }>`
  position: absolute;
  left: 0;
  right: 0;
  height: 0;
  ${({ position }) => (position === 'top' ? topDropDownPosition : bottomDropDownPosition)}
`;

const DropDownWrapper = styled.div`
  width: 100%;
`;

const topDropDownPosition = css`
  top: 0;

  ${DropDownWrapper} {
    position: absolute;
    right: 0;
    bottom: 8px;
  }
`;

const bottomDropDownPosition = css`
  bottom: 0;

  ${DropDownWrapper} {
    position: absolute;
    right: 0;
    top: 8px;
  }
`;

interface PositionInPortalProps {
  targetRef: React.RefObject<HTMLElement>;
  parentRef: React.RefObject<HTMLElement>;
  open: boolean;
}

export const PositionInPortal: FC<PositionInPortalProps> = ({ targetRef, parentRef, children, open }) => {
  const positionedPortalContainerRef = useRef<HTMLDivElement>(null);
  const [dropDownDisplay, setDropDownDisplay] = useState<Position>('bottom');
  const wrapperDropDown = useRef<HTMLDivElement>(null);

  const dropDownContainerRef = useCallback(
    (node: HTMLElement | null) => {
      if (open && node) {
        setDropDownDisplay('bottom');
      }
    },
    [open],
  );

  const checkDropDownOpenPosition = useCallback(
    (
      wrapperDropDown: React.RefObject<HTMLDivElement>,
      dropDownDisplay: Position,
      setDropDownDisplay: React.Dispatch<React.SetStateAction<Position>>,
    ) => {
      if (wrapperDropDown?.current && setDropDownDisplay) {
        const node = wrapperDropDown.current;
        const rect = node.getBoundingClientRect();
        const viewportHeight = window.innerHeight;
        if (dropDownDisplay === 'bottom' && viewportHeight - rect.bottom < 0) {
          setDropDownDisplay('top');
        } else if (dropDownDisplay === 'top' && viewportHeight - rect.bottom - rect.height - 100 > 0) {
          setDropDownDisplay('bottom');
        }
      }
    },
    [],
  );

  useEffect(() => {
    const node = positionedPortalContainerRef.current;
    const parentHeigth = parentRef.current?.getBoundingClientRect().height || 0;
    if (node && targetRef.current) {
      const observer = observeRect(targetRef.current, (rect) => {
        if (rect) {
          const { x, y, height, width } = rect;
          const { style } = node;
          style.top = `${dropDownDisplay === 'top' ? y - parentHeigth : y}px`;
          style.left = `${x - 1}px`;
          style.height = `${height}px`;
          style.width = `${width + 2}px`;
        }
      });
      observer.observe();
      return () => {
        observer.unobserve();
      };
    }
  }, [targetRef.current, positionedPortalContainerRef.current, dropDownDisplay]);

  useInterval(checkDropDownOpenPosition, 500, wrapperDropDown, dropDownDisplay, setDropDownDisplay);

  return createPortal(
    <PositionedPortalContainer ref={positionedPortalContainerRef}>
      <DropDownContainer ref={dropDownContainerRef} position={dropDownDisplay}>
        <DropDownWrapper ref={wrapperDropDown}>{children}</DropDownWrapper>
      </DropDownContainer>
    </PositionedPortalContainer>,
    document.body,
  );
};
