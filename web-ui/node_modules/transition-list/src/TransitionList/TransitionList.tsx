import React, { useEffect, useLayoutEffect, useRef, useState } from 'react';

import type { ChildHeight, RenderChild } from './types';
import type { ReactElement, ReactNode } from 'react';

import { mergeChildrenForRender } from './utils';

type PropsType = {
    className?: string
}

export const TransitionList: React.FC<PropsType> = props => {

    const { className, children } = props;

    const [, forceUpdate] = useState({});

    const childrenHeight = useRef<Array<ChildHeight>>([]);
    const deferredChildren = useRef<Array<ReactNode>>([]);
    const parentNode = useRef<HTMLDivElement>(null);
    const prevChildren = useRef<ReactNode>([]);
    const renderChildren = useRef<Array<RenderChild>>([]);

    const wasUnmount = useRef(false);
    const isAnimated = useRef(false);

    if (isAnimated.current) {
        deferredChildren.current.push(children);
    } else {
        const nextChildren = deferredChildren.current[0] || children;
        renderChildren.current = mergeChildrenForRender(
            prevChildren.current,
            nextChildren,
            childrenHeight.current,
        );
        prevChildren.current = nextChildren;
        deferredChildren.current.shift();
    }

    useLayoutEffect(() => {

        const childNodes = parentNode.current?.childNodes as NodeListOf<HTMLElement>;

        if (!isAnimated.current && parentNode.current && childNodes.length) {

            const hasAnimatedChildren = !!parentNode.current.querySelectorAll('div[data-render-type]').length;

            if (hasAnimatedChildren) {

                isAnimated.current = true;

                childrenHeight.current.length = 0;
                let rerenderDelay = 0;

                const hasNew = parentNode.current.querySelectorAll('div[data-render-type="NEW"]').length;
                const hasMoved = parentNode.current.querySelectorAll('div[data-render-type="MOVED"]').length;
                const hasRemoved = parentNode.current.querySelectorAll('div[data-render-type="REMOVED"]').length;
                const hasAllNew = hasNew === childNodes.length;

                childNodes.forEach((cn) => {

                    cn.style.visibility = 'visible';
                    cn.style.position = 'unset';

                    const firstChildStyle = getComputedStyle(cn.firstChild as HTMLElement);
                    const height =
                        cn.offsetHeight +
                        parseInt(firstChildStyle.marginTop) +
                        parseInt(firstChildStyle.marginBottom);
                    if (cn.dataset.key) {
                        childrenHeight.current.push({ key: cn.dataset.key, height });
                    }

                    switch (cn.dataset.renderType) {

                        case 'NEW':
                            cn.style.height = '0';
                            const delay = hasAllNew || (!hasMoved && !hasRemoved) ? 0 : 400;
                            setTimeout(() => {
                                cn.style.transition = 'height ease 0.3s, opacity ease 0.2s 0.20s';
                                cn.style.height = `${height}px`;
                                cn.style.opacity = '1';
                            }, delay);
                            rerenderDelay = Math.max(rerenderDelay, delay + 400);
                            break;

                        case 'MOVED':
                            cn.style.transition = 'transform ease 0.4s';
                            cn.style.transform = 'none';
                            rerenderDelay = Math.max(rerenderDelay, 400);
                            break;

                        case 'REMOVED':
                            cn.style.transition = 'height ease 0.2s 0.2s, opacity ease 0.2s';
                            cn.style.height = '0';
                            cn.style.opacity = '0';
                            rerenderDelay = Math.max(rerenderDelay, 400);
                            break;
                    }

                });

                setTimeout(() => {
                    const childNodes = parentNode.current?.childNodes as NodeListOf<HTMLElement>;
                    if (parentNode.current && childNodes) {
                        childNodes.forEach((cn) => {
                            cn.removeAttribute('data-render-type');
                            cn.removeAttribute('style');
                        });
                    }
                    isAnimated.current = false;
                    if (!wasUnmount.current) {
                        forceUpdate({});
                    }
                }, rerenderDelay);

            }

        }

    });

    useEffect(() => () => {
        wasUnmount.current = true;
    }, []);

    return (
        <div ref={parentNode} className={className}>
            {renderChildren.current.map(item => {

                const { child, newChild, translateY, removedChild, height } = item;
                const key = (child as ReactElement).key;

                if (newChild) return (
                    <div
                        key={key}
                        data-key={key}
                        children={child}
                        data-render-type={'NEW'}
                        style={{ opacity: 0, visibility: 'hidden', position: 'absolute' }}
                    />
                );

                if (removedChild) return (
                    <div
                        key={key}
                        data-key={key}
                        children={child}
                        data-render-type={'REMOVED'}
                        style={{ transform: `translateY(${translateY}px)`, height: `${height}px` }}
                    />
                );

                if (translateY) return (
                    <div
                        key={key}
                        data-key={key}
                        children={child}
                        data-render-type={'MOVED'}
                        style={{ transform: `translateY(${translateY}px)` }}
                    />
                );

                return (
                    <div
                        key={key}
                        data-key={key}
                        children={child}
                    />
                );
            })}
        </div>
    );
};