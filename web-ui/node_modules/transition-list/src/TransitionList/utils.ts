import React from 'react';

import type { Key, ReactElement, ReactNode } from 'react';
import type { ChildHeight, RenderChild } from './types';

export const calculateTopPosition = (children: ReactNode, childrenHeight: Array<ChildHeight>, key: Key | null) => {
    let found = false;
    return React.Children.toArray(children).reduce((acc: number, child: any) => {
        const childKey = child.key.replace('.$', '');
        if (found || key === null || key === childKey) {
            found = true;
            return acc;
        } else {
            const itemHeight = childrenHeight.find((i) => i.key === childKey)?.height || 0;
            return acc + itemHeight;
        }
    }, 0);
};

export const mergeChildrenForRender = (
    prevChildren: ReactNode,
    nextChildren: ReactNode,
    childrenHeight: Array<ChildHeight>,
): Array<RenderChild> | [] => {

    const resultChildren: Array<ReactNode> = [];

    // Copying all new
    React.Children.forEach<ReactNode>(nextChildren, child => resultChildren.push(child));

    // Copying all removed
    React.Children.forEach<ReactNode>(prevChildren, (child, index) => {
        const key = (child as ReactElement).key;
        const isRemoved = !React.Children.toArray(nextChildren).some((nc: any) => nc.key.replace('.$', '') === key);
        if (isRemoved) resultChildren.splice(index, 0, child);
    });

    // Create an object with attributes for rendering
    const result = React.Children.map<RenderChild, ReactNode>(resultChildren, child => {
        const key = (child as ReactElement).key;
        const height = (childrenHeight.find(ch => ch.key === key)?.height || 0);
        const newChild = !React.Children.toArray(prevChildren).some((pc: any) => pc.key.replace('.$', '') === key);
        const removedChild = !React.Children.toArray(nextChildren).some((pc: any) => pc.key.replace('.$', '') === key);
        return { key, child, height, newChild, removedChild };
    });

    return result?.map(item => {
        const prevTopPosition = calculateTopPosition(prevChildren, childrenHeight, item.key);
        const newTopPosition = calculateTopPosition(
            result?.filter(i => !i.newChild).map(i => i.child), childrenHeight, item.key,
        );

        const translateY = prevTopPosition - newTopPosition;
        return {
            ...item,
            translateY,
        };
    }) || [];
};