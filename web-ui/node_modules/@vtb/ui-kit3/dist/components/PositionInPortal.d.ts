import * as React from 'react';
export declare const PositionedPortalContainer: import("styled-components").StyledComponent<"div", import("styled-components").DefaultTheme, {}, never>;
export interface PositionInPortalProps {
    /** Ref на элемент, относительно которого позиционируется портал */
    targetRef: React.RefObject<HTMLElement>;
    /** Контейнер, внутри которого будет отрисован портал, по умолчанию портал рендерится в document.body */
    container?: Element;
    /** Отрисовка портала на всю ширину контейнера */
    fullContainerWidth?: boolean;
}
/**
 * При фиксированном позиционировании (как у PositionedPortalContainer) элемент позиционируется
 * всегда относительно исходного содержащего блока (окна браузера).
 * Исключение, когда один из его предков имеет свойство transform, perspective, или filter,
 * установленное на что-то иное, кроме none, в этом случае этот предок ведет
 * себя как содержащий блок. Тогда top, right, bottom и left элемента рассчитываются относительно этого содержащего блока.
 * Если у такого предка кроме transform задано свойство overflow: hidden, то элемент будет обрезаться по его краям.
 *
 * В связи с вышеописанным в качестве контейнера для портала рекомендуется выбирать элемент, у предков которого нет свойств
 * transform, perspective, или filter отличных от none. Также рекомендуется размещать контейнер портала в самом низу dom-дерева,
 * чтобы избежать возможных конфликтов стилей.
 */
export declare const PositionInPortal: ({ targetRef, container, fullContainerWidth, ...props }: React.PropsWithChildren<PositionInPortalProps>) => React.ReactPortal;
//# sourceMappingURL=PositionInPortal.d.ts.map